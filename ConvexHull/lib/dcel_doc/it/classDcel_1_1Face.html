<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Dcel Data Structure: Riferimenti per la classe Dcel::Face</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Dcel Data Structure
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generato da Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Cerca');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Cerca');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classDcel_1_1Face.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Composti</a> &#124;
<a href="#pub-types">Tipi pubblici</a> &#124;
<a href="#pub-methods">Membri pubblici</a> &#124;
<a href="#pro-methods">Membri protetti</a> &#124;
<a href="#pro-attribs">Attributi protetti</a> &#124;
<a href="#friends">Friend</a> &#124;
<a href="classDcel_1_1Face-members.html">Elenco di tutti i membri</a>  </div>
  <div class="headertitle">
<div class="title">Riferimenti per la classe Dcel::Face</div>  </div>
</div><!--header-->
<div class="contents">

<p>Classe rappresentante una faccia della <a class="el" href="classDcel.html" title="Struttura dati Double Conntected Edge List. ">Dcel</a>.  
 <a href="classDcel_1_1Face.html#details">Continua...</a></p>

<p><code>#include &lt;<a class="el" href="dcel__face_8h_source.html">dcel_face.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Composti</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Face_1_1ConstIncidentHalfEdgeIterator.html">ConstIncidentHalfEdgeIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iteratore che permette di ciclare sugli half edge incidenti ad una faccia, garantendone l'immutabilità.  <a href="classDcel_1_1Face_1_1ConstIncidentHalfEdgeIterator.html#details">Continua...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Face_1_1ConstIncidentVertexIterator.html">ConstIncidentVertexIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iteratore che permette di ciclare sui vertici incidenti ad una faccia, garantendone l'immutabilità.  <a href="classDcel_1_1Face_1_1ConstIncidentVertexIterator.html#details">Continua...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Face_1_1ConstInnerHalfEdgeIterator.html">ConstInnerHalfEdgeIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iteratore che permette di ciclare sul vettore degli inner half edge associati alla faccia, garantendone l'immutabilità.  <a href="classDcel_1_1Face_1_1ConstInnerHalfEdgeIterator.html#details">Continua...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Face_1_1IncidentHalfEdgeIterator.html">IncidentHalfEdgeIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iteratore che permette di ciclare sugli half edge incidenti ad una faccia.  <a href="classDcel_1_1Face_1_1IncidentHalfEdgeIterator.html#details">Continua...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Face_1_1IncidentVertexIterator.html">IncidentVertexIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iteratore che permette di ciclare sui vertici incidenti ad una faccia.  <a href="classDcel_1_1Face_1_1IncidentVertexIterator.html#details">Continua...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Tipi pubblici</h2></td></tr>
<tr class="memitem:acb9ade9788ff2df9de827f3f7ea784b8"><td class="memItemLeft" align="right" valign="top"><a id="acb9ade9788ff2df9de827f3f7ea784b8"></a>
typedef std::vector&lt; <a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> * &gt;::iterator&#160;</td><td class="memItemRight" valign="bottom"><b>InnerHalfEdgeIterator</b></td></tr>
<tr class="separator:acb9ade9788ff2df9de827f3f7ea784b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Membri pubblici</h2></td></tr>
<tr class="memitem:a0ff512044e70664311a734ec8552a34b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Face.html#a0ff512044e70664311a734ec8552a34b">Face</a> ()</td></tr>
<tr class="memdesc:a0ff512044e70664311a734ec8552a34b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Costruttore di default.  <a href="#a0ff512044e70664311a734ec8552a34b">Continua...</a><br /></td></tr>
<tr class="separator:a0ff512044e70664311a734ec8552a34b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81201ef173a9d61b54358c228fa94213"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Face.html#a81201ef173a9d61b54358c228fa94213">Face</a> (<a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *outer)</td></tr>
<tr class="memdesc:a81201ef173a9d61b54358c228fa94213"><td class="mdescLeft">&#160;</td><td class="mdescRight">Costruttore.  <a href="#a81201ef173a9d61b54358c228fa94213">Continua...</a><br /></td></tr>
<tr class="separator:a81201ef173a9d61b54358c228fa94213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a110776298d887a6af85c9752ad83d21c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Face.html#a110776298d887a6af85c9752ad83d21c">Face</a> (<a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *outer, const <a class="el" href="classPoint.html">Vec3</a> &amp;<a class="el" href="classDcel_1_1Face.html#a5192e2103d23e1205fd40c676a922fb5">normal</a>)</td></tr>
<tr class="memdesc:a110776298d887a6af85c9752ad83d21c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Costruttore.  <a href="#a110776298d887a6af85c9752ad83d21c">Continua...</a><br /></td></tr>
<tr class="separator:a110776298d887a6af85c9752ad83d21c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c5c081a14f17c8511b0d287c1a2a1ab"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Face.html#a6c5c081a14f17c8511b0d287c1a2a1ab">~Face</a> ()</td></tr>
<tr class="memdesc:a6c5c081a14f17c8511b0d287c1a2a1ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Distruttore vuoto.  <a href="#a6c5c081a14f17c8511b0d287c1a2a1ab">Continua...</a><br /></td></tr>
<tr class="separator:a6c5c081a14f17c8511b0d287c1a2a1ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31262c9a6006f4137f7f159b2d31e2aa"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Face.html#a31262c9a6006f4137f7f159b2d31e2aa">getId</a> () const</td></tr>
<tr class="memdesc:a31262c9a6006f4137f7f159b2d31e2aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restituisce l'id identificativo nella <a class="el" href="classDcel.html" title="Struttura dati Double Conntected Edge List. ">Dcel</a> della faccia.  <a href="#a31262c9a6006f4137f7f159b2d31e2aa">Continua...</a><br /></td></tr>
<tr class="separator:a31262c9a6006f4137f7f159b2d31e2aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0c471145b3175794eb4b04e06c4bb87"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Face.html#aa0c471145b3175794eb4b04e06c4bb87">getFlag</a> () const</td></tr>
<tr class="memdesc:aa0c471145b3175794eb4b04e06c4bb87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restituisce il flag associato alla faccia.  <a href="#aa0c471145b3175794eb4b04e06c4bb87">Continua...</a><br /></td></tr>
<tr class="separator:aa0c471145b3175794eb4b04e06c4bb87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94395cd1222facb2d96c66c2a1b4192b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Face.html#a94395cd1222facb2d96c66c2a1b4192b">getNormal</a> () const</td></tr>
<tr class="memdesc:a94395cd1222facb2d96c66c2a1b4192b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restituisce il vettore normale alla faccia.  <a href="#a94395cd1222facb2d96c66c2a1b4192b">Continua...</a><br /></td></tr>
<tr class="separator:a94395cd1222facb2d96c66c2a1b4192b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af59364cf1dc84200e566d601b621d068"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Face.html#af59364cf1dc84200e566d601b621d068">getArea</a> () const</td></tr>
<tr class="memdesc:af59364cf1dc84200e566d601b621d068"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restituisce la superficie della faccia.  <a href="#af59364cf1dc84200e566d601b621d068">Continua...</a><br /></td></tr>
<tr class="separator:af59364cf1dc84200e566d601b621d068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e67719f3a1ce31700730024cc2b9e9c"><td class="memItemLeft" align="right" valign="top">QColor&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Face.html#a3e67719f3a1ce31700730024cc2b9e9c">getColor</a> () const</td></tr>
<tr class="memdesc:a3e67719f3a1ce31700730024cc2b9e9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restituisce il colore associato alla faccia.  <a href="#a3e67719f3a1ce31700730024cc2b9e9c">Continua...</a><br /></td></tr>
<tr class="separator:a3e67719f3a1ce31700730024cc2b9e9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4351e1633fb091b2190f9adf9f8ccfd4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Face.html#a4351e1633fb091b2190f9adf9f8ccfd4">getOuterHalfEdge</a> () const</td></tr>
<tr class="memdesc:a4351e1633fb091b2190f9adf9f8ccfd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restituisce il puntatore all'half edge costante di bordo esterno della faccia.  <a href="#a4351e1633fb091b2190f9adf9f8ccfd4">Continua...</a><br /></td></tr>
<tr class="separator:a4351e1633fb091b2190f9adf9f8ccfd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4363d2e5d30672486cd6bbdf5a9e3f34"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Face.html#a4363d2e5d30672486cd6bbdf5a9e3f34">getNumberInnerHalfEdges</a> () const</td></tr>
<tr class="memdesc:a4363d2e5d30672486cd6bbdf5a9e3f34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restituisce il numero di inner half edges contenuti nella faccia, ossia il numero di buchi.  <a href="#a4363d2e5d30672486cd6bbdf5a9e3f34">Continua...</a><br /></td></tr>
<tr class="separator:a4363d2e5d30672486cd6bbdf5a9e3f34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64f0b0cbebb36f7bab44b45c50b56d95"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Face.html#a64f0b0cbebb36f7bab44b45c50b56d95">hasHoles</a> () const</td></tr>
<tr class="memdesc:a64f0b0cbebb36f7bab44b45c50b56d95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restituisce true se la faccia contiene buchi.  <a href="#a64f0b0cbebb36f7bab44b45c50b56d95">Continua...</a><br /></td></tr>
<tr class="separator:a64f0b0cbebb36f7bab44b45c50b56d95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a279ff3a8968f503bc74a84458ff909a4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Face.html#a279ff3a8968f503bc74a84458ff909a4">operator==</a> (const <a class="el" href="classDcel_1_1Face.html">Face</a> &amp;otherFace) const</td></tr>
<tr class="memdesc:a279ff3a8968f503bc74a84458ff909a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operatore di uguaglianza tra facce.  <a href="#a279ff3a8968f503bc74a84458ff909a4">Continua...</a><br /></td></tr>
<tr class="separator:a279ff3a8968f503bc74a84458ff909a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c5678187ef14564ae9995bacb14c711"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Face.html#a1c5678187ef14564ae9995bacb14c711">operator!=</a> (const <a class="el" href="classDcel_1_1Face.html">Face</a> &amp;otherFace) const</td></tr>
<tr class="memdesc:a1c5678187ef14564ae9995bacb14c711"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operatore di disuguaglianza tra facce.  <a href="#a1c5678187ef14564ae9995bacb14c711">Continua...</a><br /></td></tr>
<tr class="separator:a1c5678187ef14564ae9995bacb14c711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abffc69d9e8848e5c4a8bf5edfd85703b"><td class="memItemLeft" align="right" valign="top"><a id="abffc69d9e8848e5c4a8bf5edfd85703b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Face.html#abffc69d9e8848e5c4a8bf5edfd85703b">setFlag</a> ()</td></tr>
<tr class="memdesc:abffc69d9e8848e5c4a8bf5edfd85703b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setta il flag della faccia a 1. <br /></td></tr>
<tr class="separator:abffc69d9e8848e5c4a8bf5edfd85703b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa604cccda19f4c3a1de587b821e7a30a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Face.html#aa604cccda19f4c3a1de587b821e7a30a">setFlag</a> (int newFlag)</td></tr>
<tr class="memdesc:aa604cccda19f4c3a1de587b821e7a30a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setta il flag della faccia.  <a href="#aa604cccda19f4c3a1de587b821e7a30a">Continua...</a><br /></td></tr>
<tr class="separator:aa604cccda19f4c3a1de587b821e7a30a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaad66cf7fc28843ce5f1a53f4dbf4bf1"><td class="memItemLeft" align="right" valign="top"><a id="aaad66cf7fc28843ce5f1a53f4dbf4bf1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Face.html#aaad66cf7fc28843ce5f1a53f4dbf4bf1">resetFlag</a> ()</td></tr>
<tr class="memdesc:aaad66cf7fc28843ce5f1a53f4dbf4bf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setta il flag della faccia a 0. <br /></td></tr>
<tr class="separator:aaad66cf7fc28843ce5f1a53f4dbf4bf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b44bed402a0bf5ab57203408dab1848"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Face.html#a7b44bed402a0bf5ab57203408dab1848">setNormal</a> (const <a class="el" href="classPoint.html">Vec3</a> &amp;newNormal)</td></tr>
<tr class="memdesc:a7b44bed402a0bf5ab57203408dab1848"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setta il vettore normale della faccia.  <a href="#a7b44bed402a0bf5ab57203408dab1848">Continua...</a><br /></td></tr>
<tr class="separator:a7b44bed402a0bf5ab57203408dab1848"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02676459ce353dba0b0983911268ff96"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Face.html#a02676459ce353dba0b0983911268ff96">setArea</a> (double newArea)</td></tr>
<tr class="memdesc:a02676459ce353dba0b0983911268ff96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setta la superficie della faccia.  <a href="#a02676459ce353dba0b0983911268ff96">Continua...</a><br /></td></tr>
<tr class="separator:a02676459ce353dba0b0983911268ff96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a622a92cad8c5ee5fa973e96e9b5a0421"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Face.html#a622a92cad8c5ee5fa973e96e9b5a0421">setColor</a> (const QColor &amp;newColor)</td></tr>
<tr class="memdesc:a622a92cad8c5ee5fa973e96e9b5a0421"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assegna un nuovo colore alla faccia.  <a href="#a622a92cad8c5ee5fa973e96e9b5a0421">Continua...</a><br /></td></tr>
<tr class="separator:a622a92cad8c5ee5fa973e96e9b5a0421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60b90e36a636a02e1701927953db635c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Face.html#a60b90e36a636a02e1701927953db635c">getOuterHalfEdge</a> ()</td></tr>
<tr class="memdesc:a60b90e36a636a02e1701927953db635c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restituisce il puntatore all'half edge di bordo esterno della faccia.  <a href="#a60b90e36a636a02e1701927953db635c">Continua...</a><br /></td></tr>
<tr class="separator:a60b90e36a636a02e1701927953db635c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af14047c54344631b42bf5a7758ade2a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Face.html#af14047c54344631b42bf5a7758ade2a7">setOuterHalfEdge</a> (<a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *newOuterHalfEdge)</td></tr>
<tr class="memdesc:af14047c54344631b42bf5a7758ade2a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assegna un nuovo half edge di bordo esterno alla faccia.  <a href="#af14047c54344631b42bf5a7758ade2a7">Continua...</a><br /></td></tr>
<tr class="separator:af14047c54344631b42bf5a7758ade2a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15e18b8354693674b78eab4af30c59ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Face.html#a15e18b8354693674b78eab4af30c59ff">addInnerHalfEdge</a> (<a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *newInnerHalfEdge)</td></tr>
<tr class="memdesc:a15e18b8354693674b78eab4af30c59ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aggiunge un nuovo half edge di bordo interno (ossia un buco) alla faccia.  <a href="#a15e18b8354693674b78eab4af30c59ff">Continua...</a><br /></td></tr>
<tr class="separator:a15e18b8354693674b78eab4af30c59ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ba07291a4a48adefbd52b3e25b99335"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Face.html#a0ba07291a4a48adefbd52b3e25b99335">isTriangle</a> () const</td></tr>
<tr class="memdesc:a0ba07291a4a48adefbd52b3e25b99335"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione che verifica se la faccia è un triangolo.  <a href="#a0ba07291a4a48adefbd52b3e25b99335">Continua...</a><br /></td></tr>
<tr class="separator:a0ba07291a4a48adefbd52b3e25b99335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadb995d50381bba4dda1076bac42a85a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Face.html#aadb995d50381bba4dda1076bac42a85a">getNumberIncidentVertices</a> () const</td></tr>
<tr class="memdesc:aadb995d50381bba4dda1076bac42a85a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restituisce il numero di vertici incidenti alla faccia.  <a href="#aadb995d50381bba4dda1076bac42a85a">Continua...</a><br /></td></tr>
<tr class="separator:aadb995d50381bba4dda1076bac42a85a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a162d0e06202b30fe8e536d21dfbabf4c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Face.html#a162d0e06202b30fe8e536d21dfbabf4c">getNumberIncidentHalfEdges</a> () const</td></tr>
<tr class="memdesc:a162d0e06202b30fe8e536d21dfbabf4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restituisce il numero di half edge incidenti alla faccia.  <a href="#a162d0e06202b30fe8e536d21dfbabf4c">Continua...</a><br /></td></tr>
<tr class="separator:a162d0e06202b30fe8e536d21dfbabf4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bd82f7a9cc0b888f7d06e650b25f4ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Pointd</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Face.html#a2bd82f7a9cc0b888f7d06e650b25f4ce">getBarycentre</a> () const</td></tr>
<tr class="memdesc:a2bd82f7a9cc0b888f7d06e650b25f4ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calcola e restituisce il baricentro della faccia.  <a href="#a2bd82f7a9cc0b888f7d06e650b25f4ce">Continua...</a><br /></td></tr>
<tr class="separator:a2bd82f7a9cc0b888f7d06e650b25f4ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab83c5c47cd7c97c6c9182b586642fff2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Face.html#ab83c5c47cd7c97c6c9182b586642fff2">toString</a> () const</td></tr>
<tr class="memdesc:ab83c5c47cd7c97c6c9182b586642fff2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione toString di una faccia.  <a href="#ab83c5c47cd7c97c6c9182b586642fff2">Continua...</a><br /></td></tr>
<tr class="separator:ab83c5c47cd7c97c6c9182b586642fff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae658f73323ae563c330d276c4d712235"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Face_1_1ConstInnerHalfEdgeIterator.html">ConstInnerHalfEdgeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Face.html#ae658f73323ae563c330d276c4d712235">innerHalfEdgeBegin</a> () const</td></tr>
<tr class="memdesc:ae658f73323ae563c330d276c4d712235"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di inizializzazione di <a class="el" href="classDcel_1_1Face_1_1ConstInnerHalfEdgeIterator.html" title="Iteratore che permette di ciclare sul vettore degli inner half edge associati alla faccia...">Dcel::Face::ConstInnerHalfEdgeIterator</a>.  <a href="#ae658f73323ae563c330d276c4d712235">Continua...</a><br /></td></tr>
<tr class="separator:ae658f73323ae563c330d276c4d712235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07a015358abb89178a3e74e337706cab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Face_1_1ConstInnerHalfEdgeIterator.html">ConstInnerHalfEdgeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Face.html#a07a015358abb89178a3e74e337706cab">innerHalfEdgeEnd</a> () const</td></tr>
<tr class="memdesc:a07a015358abb89178a3e74e337706cab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di finalizzazione di <a class="el" href="classDcel_1_1Face_1_1ConstInnerHalfEdgeIterator.html" title="Iteratore che permette di ciclare sul vettore degli inner half edge associati alla faccia...">Dcel::Face::ConstInnerHalfEdgeIterator</a>.  <a href="#a07a015358abb89178a3e74e337706cab">Continua...</a><br /></td></tr>
<tr class="separator:a07a015358abb89178a3e74e337706cab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70bfb28e1852cadcb84bc865ebd688b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Face_1_1ConstIncidentHalfEdgeIterator.html">ConstIncidentHalfEdgeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Face.html#a70bfb28e1852cadcb84bc865ebd688b0">incidentHalfEdgeBegin</a> () const</td></tr>
<tr class="memdesc:a70bfb28e1852cadcb84bc865ebd688b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di inizializzazione di <a class="el" href="classDcel_1_1Face_1_1ConstIncidentHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge incidenti ad una faccia, garantendone l&#39;immutabilit...">Dcel::Face::ConstIncidentHalfEdgeIterator</a>.  <a href="#a70bfb28e1852cadcb84bc865ebd688b0">Continua...</a><br /></td></tr>
<tr class="separator:a70bfb28e1852cadcb84bc865ebd688b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c7a4d4d5643fdf6df7806483f12fffa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Face_1_1ConstIncidentHalfEdgeIterator.html">ConstIncidentHalfEdgeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Face.html#a0c7a4d4d5643fdf6df7806483f12fffa">incidentHalfEdgeEnd</a> () const</td></tr>
<tr class="memdesc:a0c7a4d4d5643fdf6df7806483f12fffa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di finalizzazione di <a class="el" href="classDcel_1_1Face_1_1ConstIncidentHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge incidenti ad una faccia, garantendone l&#39;immutabilit...">Dcel::Face::ConstIncidentHalfEdgeIterator</a>.  <a href="#a0c7a4d4d5643fdf6df7806483f12fffa">Continua...</a><br /></td></tr>
<tr class="separator:a0c7a4d4d5643fdf6df7806483f12fffa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8aa4fe2aa6e7df2469a202157918f14"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Face_1_1ConstIncidentHalfEdgeIterator.html">ConstIncidentHalfEdgeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Face.html#ad8aa4fe2aa6e7df2469a202157918f14">incidentHalfEdgeBegin</a> (const <a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *start) const</td></tr>
<tr class="memdesc:ad8aa4fe2aa6e7df2469a202157918f14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di inizializzazione di <a class="el" href="classDcel_1_1Face_1_1ConstIncidentHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge incidenti ad una faccia, garantendone l&#39;immutabilit...">Dcel::Face::ConstIncidentHalfEdgeIterator</a>.  <a href="#ad8aa4fe2aa6e7df2469a202157918f14">Continua...</a><br /></td></tr>
<tr class="separator:ad8aa4fe2aa6e7df2469a202157918f14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a95df38fec97e4583c1633b784bf60e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Face_1_1ConstIncidentHalfEdgeIterator.html">ConstIncidentHalfEdgeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Face.html#a4a95df38fec97e4583c1633b784bf60e">incidentHalfEdgeBegin</a> (const <a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *start, const <a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *end) const</td></tr>
<tr class="memdesc:a4a95df38fec97e4583c1633b784bf60e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di inizializzazione di <a class="el" href="classDcel_1_1Face_1_1ConstIncidentHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge incidenti ad una faccia, garantendone l&#39;immutabilit...">Dcel::Face::ConstIncidentHalfEdgeIterator</a>.  <a href="#a4a95df38fec97e4583c1633b784bf60e">Continua...</a><br /></td></tr>
<tr class="separator:a4a95df38fec97e4583c1633b784bf60e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa151c9c356a3ecc755a4e171d65641da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Face_1_1ConstIncidentVertexIterator.html">ConstIncidentVertexIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Face.html#aa151c9c356a3ecc755a4e171d65641da">incidentVertexBegin</a> () const</td></tr>
<tr class="memdesc:aa151c9c356a3ecc755a4e171d65641da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di inizializzazione di <a class="el" href="classDcel_1_1Face_1_1ConstIncidentVertexIterator.html" title="Iteratore che permette di ciclare sui vertici incidenti ad una faccia, garantendone l&#39;immutabilità...">Dcel::Face::ConstIncidentVertexIterator</a>.  <a href="#aa151c9c356a3ecc755a4e171d65641da">Continua...</a><br /></td></tr>
<tr class="separator:aa151c9c356a3ecc755a4e171d65641da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8daecf496c56a8eb3ea9dee6e167abc8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Face_1_1ConstIncidentVertexIterator.html">ConstIncidentVertexIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Face.html#a8daecf496c56a8eb3ea9dee6e167abc8">incidentVertexEnd</a> () const</td></tr>
<tr class="memdesc:a8daecf496c56a8eb3ea9dee6e167abc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di finalizzazione di <a class="el" href="classDcel_1_1Face_1_1ConstIncidentVertexIterator.html" title="Iteratore che permette di ciclare sui vertici incidenti ad una faccia, garantendone l&#39;immutabilità...">Dcel::Face::ConstIncidentVertexIterator</a>.  <a href="#a8daecf496c56a8eb3ea9dee6e167abc8">Continua...</a><br /></td></tr>
<tr class="separator:a8daecf496c56a8eb3ea9dee6e167abc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77e6420bf3bc21e9dd6ba00e54a5412b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Face_1_1ConstIncidentVertexIterator.html">ConstIncidentVertexIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Face.html#a77e6420bf3bc21e9dd6ba00e54a5412b">incidentVertexBegin</a> (const <a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *start) const</td></tr>
<tr class="memdesc:a77e6420bf3bc21e9dd6ba00e54a5412b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di inizializzazione di <a class="el" href="classDcel_1_1Face_1_1ConstIncidentVertexIterator.html" title="Iteratore che permette di ciclare sui vertici incidenti ad una faccia, garantendone l&#39;immutabilità...">Dcel::Face::ConstIncidentVertexIterator</a>.  <a href="#a77e6420bf3bc21e9dd6ba00e54a5412b">Continua...</a><br /></td></tr>
<tr class="separator:a77e6420bf3bc21e9dd6ba00e54a5412b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1a7f528f3fff84561144e25eff9b79a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Face_1_1ConstIncidentVertexIterator.html">ConstIncidentVertexIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Face.html#ac1a7f528f3fff84561144e25eff9b79a">incidentVertexBegin</a> (const <a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *start, const <a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *end) const</td></tr>
<tr class="memdesc:ac1a7f528f3fff84561144e25eff9b79a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di inizializzazione di <a class="el" href="classDcel_1_1Face_1_1ConstIncidentVertexIterator.html" title="Iteratore che permette di ciclare sui vertici incidenti ad una faccia, garantendone l&#39;immutabilità...">Dcel::Face::ConstIncidentVertexIterator</a>.  <a href="#ac1a7f528f3fff84561144e25eff9b79a">Continua...</a><br /></td></tr>
<tr class="separator:ac1a7f528f3fff84561144e25eff9b79a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade7ea1ce7355caab78a50ab950e3dc4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Face_1_1ConstIncidentVertexIterator.html">ConstIncidentVertexIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Face.html#ade7ea1ce7355caab78a50ab950e3dc4a">incidentVertexBegin</a> (const <a class="el" href="classDcel_1_1Vertex.html">Dcel::Vertex</a> *start) const</td></tr>
<tr class="memdesc:ade7ea1ce7355caab78a50ab950e3dc4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di inizializzazione di <a class="el" href="classDcel_1_1Face_1_1ConstIncidentVertexIterator.html" title="Iteratore che permette di ciclare sui vertici incidenti ad una faccia, garantendone l&#39;immutabilità...">Dcel::Face::ConstIncidentVertexIterator</a>.  <a href="#ade7ea1ce7355caab78a50ab950e3dc4a">Continua...</a><br /></td></tr>
<tr class="separator:ade7ea1ce7355caab78a50ab950e3dc4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae532c7fce4523b34c103c6a22d0b5726"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Face_1_1ConstIncidentVertexIterator.html">ConstIncidentVertexIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Face.html#ae532c7fce4523b34c103c6a22d0b5726">incidentVertexBegin</a> (const <a class="el" href="classDcel_1_1Vertex.html">Dcel::Vertex</a> *start, const <a class="el" href="classDcel_1_1Vertex.html">Dcel::Vertex</a> *end) const</td></tr>
<tr class="memdesc:ae532c7fce4523b34c103c6a22d0b5726"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di inizializzazione di <a class="el" href="classDcel_1_1Face_1_1ConstIncidentVertexIterator.html" title="Iteratore che permette di ciclare sui vertici incidenti ad una faccia, garantendone l&#39;immutabilità...">Dcel::Face::ConstIncidentVertexIterator</a>.  <a href="#ae532c7fce4523b34c103c6a22d0b5726">Continua...</a><br /></td></tr>
<tr class="separator:ae532c7fce4523b34c103c6a22d0b5726"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ad77590c260b153376cf06b8b1edad8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Face.html#a4ad77590c260b153376cf06b8b1edad8">updateNormal</a> ()</td></tr>
<tr class="memdesc:a4ad77590c260b153376cf06b8b1edad8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione che aggiorna la normale alla faccia.  <a href="#a4ad77590c260b153376cf06b8b1edad8">Continua...</a><br /></td></tr>
<tr class="separator:a4ad77590c260b153376cf06b8b1edad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9dc660372a1981c9dc23268be6deea3"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Face.html#ae9dc660372a1981c9dc23268be6deea3">updateArea</a> ()</td></tr>
<tr class="memdesc:ae9dc660372a1981c9dc23268be6deea3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione che aggiorna l'area della faccia.  <a href="#ae9dc660372a1981c9dc23268be6deea3">Continua...</a><br /></td></tr>
<tr class="separator:ae9dc660372a1981c9dc23268be6deea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b2bea820a1f41f745889f1a3b3004ba"><td class="memItemLeft" align="right" valign="top"><a id="a6b2bea820a1f41f745889f1a3b3004ba"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>removeInnerHalfEdge</b> (const <a class="el" href="classInnerHalfEdgeIterator.html">InnerHalfEdgeIterator</a> &amp;iterator)</td></tr>
<tr class="separator:a6b2bea820a1f41f745889f1a3b3004ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c86481d66af33c6c89c886d039d0a85"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Face.html#a9c86481d66af33c6c89c886d039d0a85">removeInnerHalfEdge</a> (const <a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *halfEdge)</td></tr>
<tr class="memdesc:a9c86481d66af33c6c89c886d039d0a85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione che rimuove un inner half edge dalla faccia.  <a href="#a9c86481d66af33c6c89c886d039d0a85">Continua...</a><br /></td></tr>
<tr class="separator:a9c86481d66af33c6c89c886d039d0a85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02f9d0c656c2612d73f6acefc3edb7f4"><td class="memItemLeft" align="right" valign="top"><a id="a02f9d0c656c2612d73f6acefc3edb7f4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>removeAllInnerHalfEdges</b> ()</td></tr>
<tr class="separator:a02f9d0c656c2612d73f6acefc3edb7f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a561aff52c205ceb05b6fc5d57850a4f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classInnerHalfEdgeIterator.html">InnerHalfEdgeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Face.html#a561aff52c205ceb05b6fc5d57850a4f7">innerHalfEdgeBegin</a> ()</td></tr>
<tr class="memdesc:a561aff52c205ceb05b6fc5d57850a4f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di inizializzazione di Dcel::Face::InnerHalfEdgeIterator.  <a href="#a561aff52c205ceb05b6fc5d57850a4f7">Continua...</a><br /></td></tr>
<tr class="separator:a561aff52c205ceb05b6fc5d57850a4f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a737316644d40e7157f3c6cd90eb7853e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classInnerHalfEdgeIterator.html">InnerHalfEdgeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Face.html#a737316644d40e7157f3c6cd90eb7853e">innerHalfEdgeEnd</a> ()</td></tr>
<tr class="memdesc:a737316644d40e7157f3c6cd90eb7853e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di finalizzazione di Dcel::Face::InnerHalfEdgeIterator.  <a href="#a737316644d40e7157f3c6cd90eb7853e">Continua...</a><br /></td></tr>
<tr class="separator:a737316644d40e7157f3c6cd90eb7853e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e002b38ebdcf3afd7dbe1616392629a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Face_1_1IncidentHalfEdgeIterator.html">IncidentHalfEdgeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Face.html#a2e002b38ebdcf3afd7dbe1616392629a">incidentHalfEdgeBegin</a> ()</td></tr>
<tr class="memdesc:a2e002b38ebdcf3afd7dbe1616392629a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di inizializzazione di <a class="el" href="classDcel_1_1Face_1_1IncidentHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge incidenti ad una faccia. ">Dcel::Face::IncidentHalfEdgeIterator</a>.  <a href="#a2e002b38ebdcf3afd7dbe1616392629a">Continua...</a><br /></td></tr>
<tr class="separator:a2e002b38ebdcf3afd7dbe1616392629a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a688a3ed79f2081ce079b272fd9ca29cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Face_1_1IncidentHalfEdgeIterator.html">IncidentHalfEdgeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Face.html#a688a3ed79f2081ce079b272fd9ca29cb">incidentHalfEdgeEnd</a> ()</td></tr>
<tr class="memdesc:a688a3ed79f2081ce079b272fd9ca29cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di finalizzazione di <a class="el" href="classDcel_1_1Face_1_1IncidentHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge incidenti ad una faccia. ">Dcel::Face::IncidentHalfEdgeIterator</a>.  <a href="#a688a3ed79f2081ce079b272fd9ca29cb">Continua...</a><br /></td></tr>
<tr class="separator:a688a3ed79f2081ce079b272fd9ca29cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ebe49ba6d3e8b92b8b81876262166b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Face_1_1IncidentHalfEdgeIterator.html">IncidentHalfEdgeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Face.html#a2ebe49ba6d3e8b92b8b81876262166b8">incidentHalfEdgeBegin</a> (<a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *start)</td></tr>
<tr class="memdesc:a2ebe49ba6d3e8b92b8b81876262166b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di inizializzazione di <a class="el" href="classDcel_1_1Face_1_1IncidentHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge incidenti ad una faccia. ">Dcel::Face::IncidentHalfEdgeIterator</a>.  <a href="#a2ebe49ba6d3e8b92b8b81876262166b8">Continua...</a><br /></td></tr>
<tr class="separator:a2ebe49ba6d3e8b92b8b81876262166b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6951f450fae7c4f9df8e5e269249d68e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Face_1_1IncidentHalfEdgeIterator.html">IncidentHalfEdgeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Face.html#a6951f450fae7c4f9df8e5e269249d68e">incidentHalfEdgeBegin</a> (<a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *start, <a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *end)</td></tr>
<tr class="memdesc:a6951f450fae7c4f9df8e5e269249d68e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di inizializzazione di <a class="el" href="classDcel_1_1Face_1_1IncidentHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge incidenti ad una faccia. ">Dcel::Face::IncidentHalfEdgeIterator</a>.  <a href="#a6951f450fae7c4f9df8e5e269249d68e">Continua...</a><br /></td></tr>
<tr class="separator:a6951f450fae7c4f9df8e5e269249d68e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86773f03bf18efdf0b2b194d7395d76c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Face_1_1IncidentVertexIterator.html">IncidentVertexIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Face.html#a86773f03bf18efdf0b2b194d7395d76c">incidentVertexBegin</a> ()</td></tr>
<tr class="memdesc:a86773f03bf18efdf0b2b194d7395d76c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di inizializzazione di <a class="el" href="classDcel_1_1Face_1_1IncidentVertexIterator.html" title="Iteratore che permette di ciclare sui vertici incidenti ad una faccia. ">Dcel::Face::IncidentVertexIterator</a>.  <a href="#a86773f03bf18efdf0b2b194d7395d76c">Continua...</a><br /></td></tr>
<tr class="separator:a86773f03bf18efdf0b2b194d7395d76c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19f53077b101635685bb82efd225789e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Face_1_1IncidentVertexIterator.html">IncidentVertexIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Face.html#a19f53077b101635685bb82efd225789e">incidentVertexEnd</a> ()</td></tr>
<tr class="memdesc:a19f53077b101635685bb82efd225789e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di finalizzazione di <a class="el" href="classDcel_1_1Face_1_1IncidentVertexIterator.html" title="Iteratore che permette di ciclare sui vertici incidenti ad una faccia. ">Dcel::Face::IncidentVertexIterator</a>.  <a href="#a19f53077b101635685bb82efd225789e">Continua...</a><br /></td></tr>
<tr class="separator:a19f53077b101635685bb82efd225789e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfde89779c3cd1ceec15cc0600205709"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Face_1_1IncidentVertexIterator.html">IncidentVertexIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Face.html#adfde89779c3cd1ceec15cc0600205709">incidentVertexBegin</a> (<a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *start)</td></tr>
<tr class="memdesc:adfde89779c3cd1ceec15cc0600205709"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di inizializzazione di <a class="el" href="classDcel_1_1Face_1_1IncidentVertexIterator.html" title="Iteratore che permette di ciclare sui vertici incidenti ad una faccia. ">Dcel::Face::IncidentVertexIterator</a>.  <a href="#adfde89779c3cd1ceec15cc0600205709">Continua...</a><br /></td></tr>
<tr class="separator:adfde89779c3cd1ceec15cc0600205709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9be21806cfd3db916d2e69c98a55ce19"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Face_1_1IncidentVertexIterator.html">IncidentVertexIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Face.html#a9be21806cfd3db916d2e69c98a55ce19">incidentVertexBegin</a> (<a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *start, <a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *end)</td></tr>
<tr class="memdesc:a9be21806cfd3db916d2e69c98a55ce19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di inizializzazione di <a class="el" href="classDcel_1_1Face_1_1IncidentVertexIterator.html" title="Iteratore che permette di ciclare sui vertici incidenti ad una faccia. ">Dcel::Face::IncidentVertexIterator</a>.  <a href="#a9be21806cfd3db916d2e69c98a55ce19">Continua...</a><br /></td></tr>
<tr class="separator:a9be21806cfd3db916d2e69c98a55ce19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a509cd6d27a881bbb262bc57b50d72e9d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Face_1_1IncidentVertexIterator.html">IncidentVertexIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Face.html#a509cd6d27a881bbb262bc57b50d72e9d">incidentVertexBegin</a> (<a class="el" href="classDcel_1_1Vertex.html">Dcel::Vertex</a> *start)</td></tr>
<tr class="memdesc:a509cd6d27a881bbb262bc57b50d72e9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di inizializzazione di <a class="el" href="classDcel_1_1Face_1_1IncidentVertexIterator.html" title="Iteratore che permette di ciclare sui vertici incidenti ad una faccia. ">Dcel::Face::IncidentVertexIterator</a>.  <a href="#a509cd6d27a881bbb262bc57b50d72e9d">Continua...</a><br /></td></tr>
<tr class="separator:a509cd6d27a881bbb262bc57b50d72e9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a070c7fe2e49e189a09da67143ffdac51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Face_1_1IncidentVertexIterator.html">IncidentVertexIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Face.html#a070c7fe2e49e189a09da67143ffdac51">incidentVertexBegin</a> (<a class="el" href="classDcel_1_1Vertex.html">Dcel::Vertex</a> *start, <a class="el" href="classDcel_1_1Vertex.html">Dcel::Vertex</a> *end)</td></tr>
<tr class="memdesc:a070c7fe2e49e189a09da67143ffdac51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di inizializzazione di <a class="el" href="classDcel_1_1Face_1_1IncidentVertexIterator.html" title="Iteratore che permette di ciclare sui vertici incidenti ad una faccia. ">Dcel::Face::IncidentVertexIterator</a>.  <a href="#a070c7fe2e49e189a09da67143ffdac51">Continua...</a><br /></td></tr>
<tr class="separator:a070c7fe2e49e189a09da67143ffdac51"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Membri protetti</h2></td></tr>
<tr class="memitem:a3b1af1643612348b740552f4eb90a476"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Face.html#a3b1af1643612348b740552f4eb90a476">setId</a> (unsigned int <a class="el" href="classDcel_1_1Face.html#af78f54d36a4f2bb700af7c899fa15797">id</a>)</td></tr>
<tr class="memdesc:a3b1af1643612348b740552f4eb90a476"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setta l'id della faccia.  <a href="#a3b1af1643612348b740552f4eb90a476">Continua...</a><br /></td></tr>
<tr class="separator:a3b1af1643612348b740552f4eb90a476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a552fcf6add14c42c61d3959417d5ebe9"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Face.html#a552fcf6add14c42c61d3959417d5ebe9">innerComponentsToString</a> () const</td></tr>
<tr class="memdesc:a552fcf6add14c42c61d3959417d5ebe9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione che restituisce una stringa degli inner half edge.  <a href="#a552fcf6add14c42c61d3959417d5ebe9">Continua...</a><br /></td></tr>
<tr class="separator:a552fcf6add14c42c61d3959417d5ebe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Attributi protetti</h2></td></tr>
<tr class="memitem:a2c9c35c072997348d1d3ed5e972405d6"><td class="memItemLeft" align="right" valign="top"><a id="a2c9c35c072997348d1d3ed5e972405d6"></a>
<a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Face.html#a2c9c35c072997348d1d3ed5e972405d6">outerHalfEdge</a></td></tr>
<tr class="memdesc:a2c9c35c072997348d1d3ed5e972405d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uno degli half edge sul bordo della faccia. <br /></td></tr>
<tr class="separator:a2c9c35c072997348d1d3ed5e972405d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04be4505bebe680355f5dbe7bf83a72a"><td class="memItemLeft" align="right" valign="top"><a id="a04be4505bebe680355f5dbe7bf83a72a"></a>
std::vector&lt; <a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Face.html#a04be4505bebe680355f5dbe7bf83a72a">innerHalfEdges</a></td></tr>
<tr class="memdesc:a04be4505bebe680355f5dbe7bf83a72a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lista degli half edge sul bordo di eventuali buchi della faccia, uno per ogni buco. <br /></td></tr>
<tr class="separator:a04be4505bebe680355f5dbe7bf83a72a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5192e2103d23e1205fd40c676a922fb5"><td class="memItemLeft" align="right" valign="top"><a id="a5192e2103d23e1205fd40c676a922fb5"></a>
<a class="el" href="classPoint.html">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Face.html#a5192e2103d23e1205fd40c676a922fb5">normal</a></td></tr>
<tr class="memdesc:a5192e2103d23e1205fd40c676a922fb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vettore normale alla faccia. <br /></td></tr>
<tr class="separator:a5192e2103d23e1205fd40c676a922fb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a759c9f92d11bef8c3ceb1a7df841f35d"><td class="memItemLeft" align="right" valign="top"><a id="a759c9f92d11bef8c3ceb1a7df841f35d"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Face.html#a759c9f92d11bef8c3ceb1a7df841f35d">area</a></td></tr>
<tr class="memdesc:a759c9f92d11bef8c3ceb1a7df841f35d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Superficie della faccia. <br /></td></tr>
<tr class="separator:a759c9f92d11bef8c3ceb1a7df841f35d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f5b41e07ec678d26125e543c7867fdd"><td class="memItemLeft" align="right" valign="top"><a id="a6f5b41e07ec678d26125e543c7867fdd"></a>
QColor&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Face.html#a6f5b41e07ec678d26125e543c7867fdd">color</a></td></tr>
<tr class="memdesc:a6f5b41e07ec678d26125e543c7867fdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Colore associato alla faccia. <br /></td></tr>
<tr class="separator:a6f5b41e07ec678d26125e543c7867fdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af78f54d36a4f2bb700af7c899fa15797"><td class="memItemLeft" align="right" valign="top"><a id="af78f54d36a4f2bb700af7c899fa15797"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Face.html#af78f54d36a4f2bb700af7c899fa15797">id</a></td></tr>
<tr class="memdesc:af78f54d36a4f2bb700af7c899fa15797"><td class="mdescLeft">&#160;</td><td class="mdescRight">Id univoco, all'interno della <a class="el" href="classDcel.html" title="Struttura dati Double Conntected Edge List. ">Dcel</a>, associato alla faccia. <br /></td></tr>
<tr class="separator:af78f54d36a4f2bb700af7c899fa15797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba3f9a77ade2b28082df4ff18b3738ba"><td class="memItemLeft" align="right" valign="top"><a id="aba3f9a77ade2b28082df4ff18b3738ba"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Face.html#aba3f9a77ade2b28082df4ff18b3738ba">flag</a></td></tr>
<tr class="memdesc:aba3f9a77ade2b28082df4ff18b3738ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag personalizzabile, associato alla faccia. <br /></td></tr>
<tr class="separator:aba3f9a77ade2b28082df4ff18b3738ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friend</h2></td></tr>
<tr class="memitem:aa1fcaa71081ba7020ce73fec523e4d9b"><td class="memItemLeft" align="right" valign="top"><a id="aa1fcaa71081ba7020ce73fec523e4d9b"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>Dcel</b></td></tr>
<tr class="separator:aa1fcaa71081ba7020ce73fec523e4d9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Descrizione dettagliata</h2>
<div class="textblock"><p>Classe rappresentante una faccia della <a class="el" href="classDcel.html" title="Struttura dati Double Conntected Edge List. ">Dcel</a>. </p>
<p>All'interno della <a class="el" href="classDcel.html" title="Struttura dati Double Conntected Edge List. ">Dcel</a>, le sue componenti fondamentali sono:</p><ul>
<li>outerHalfEdge: un half edge incidente esterno, ossia che si trova sul bordo esterno della faccia (tutti gli altri half edge dello stesso tipo saranno individuabili mediante operazioni di next e prev dell'half edge);<br />
</li>
<li>innerHalfEdges: lista di half edge incidenti interni, ossia sul bordo di un buco interno alla faccia, un inner half edge per ogni buco della faccia (tutti gli altri half edge dello stesso tipo saranno individuabili mediante operazioni di next e prev dell'half edge).<br />
</li>
</ul>
<p>Per una gestione corretta della <a class="el" href="classDcel.html" title="Struttura dati Double Conntected Edge List. ">Dcel</a>, ogni faccia <code>f</code> deve avere un <code>outerHalfEdge</code> e 0 o più <code>innerHalfEdge</code>. Ognuno di questi questi half edge, e tutti quelli raggiungibili mediante operazioni di next e prev, devono avere come incidentFace <code>f</code>.</p>
<p>Le altre componenti che compongono la faccia sono:</p><ul>
<li>normal: vettore 3D rappresentante la normale alla faccia;<br />
</li>
<li>area: superficie della faccia;<br />
</li>
<li>color: colore associato alla faccia;<br />
</li>
<li>id: intero senza segno univoco all'interno della lista delle facce della <a class="el" href="classDcel.html" title="Struttura dati Double Conntected Edge List. ">Dcel</a>, non modificabile dall'utente. Può essere usato per identificare la faccia all'interno della <a class="el" href="classDcel.html" title="Struttura dati Double Conntected Edge List. ">Dcel</a> (in modo meno efficiente rispetto all'utilizzo di un puntatore);<br />
</li>
<li>flag: intero personalizzabile dall'utente. <br />
</li>
</ul>
<p>Sono messi a disposizione i seguenti iteratori per navigare sugli inner half edge (uno per ogni buco):</p><ul>
<li>Dcel::Face::InnerHalfEdgeIterator</li>
<li><a class="el" href="classDcel_1_1Face_1_1ConstInnerHalfEdgeIterator.html" title="Iteratore che permette di ciclare sul vettore degli inner half edge associati alla faccia...">Dcel::Face::ConstInnerHalfEdgeIterator</a></li>
</ul>
<p>Sono messi a disposizione anche i seguenti iteratori per navigare sulle componenti incidenti alla faccia:</p><ul>
<li><a class="el" href="classDcel_1_1Face_1_1IncidentHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge incidenti ad una faccia. ">Dcel::Face::IncidentHalfEdgeIterator</a></li>
<li><a class="el" href="classDcel_1_1Face_1_1IncidentVertexIterator.html" title="Iteratore che permette di ciclare sui vertici incidenti ad una faccia. ">Dcel::Face::IncidentVertexIterator</a></li>
<li><a class="el" href="classDcel_1_1Face_1_1ConstIncidentHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge incidenti ad una faccia, garantendone l&#39;immutabilit...">Dcel::Face::ConstIncidentHalfEdgeIterator</a></li>
<li><a class="el" href="classDcel_1_1Face_1_1ConstIncidentVertexIterator.html" title="Iteratore che permette di ciclare sui vertici incidenti ad una faccia, garantendone l&#39;immutabilità...">Dcel::Face::ConstIncidentVertexIterator</a></li>
</ul>
<p>Per navigare su tutti gli half edge di un buco adiacenti alla faccia, è possibile usare l'iteratore sugli half edge incidenti:</p>
<div class="fragment"><div class="line"><a class="code" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a>* firstInnerHalfEdge;</div><div class="line"><span class="keywordflow">if</span> (f-&gt;getNumberInnerHalfEdges() &gt; 0){</div><div class="line">    firstInnerHalfEdge = *(f-&gt;innerHalfEdgeBegin()); <span class="comment">//primo inner half edge della faccia</span></div><div class="line">    <span class="keywordflow">for</span> (<a class="code" href="classDcel_1_1Face_1_1IncidentHalfEdgeIterator.html">Dcel::Face::IncidentHalfEdgeIterator</a> heit = f-&gt;incidentHalfEdgeBegin(firstInnerHalfEdge); heit!=f-&gt;incidentHalfEdgeEnd(); ++heit){</div><div class="line">        <a class="code" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a>* inner = *heit;</div><div class="line">        <span class="comment">// operazioni su inner</span></div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>Il controllo sull' <code>if</code> verifica che la faccia <code>f</code> abbia almeno un inner half edge (ossia abbia almeno un buco). A questo punto, <code>firstInnerHalfEdge</code> viene fatto puntare ad un inner half edge, e viene fatto ciclare un iteratore sugli incident half edge di <code>f</code> inizializzato con <code>firstInnerHalfEdge</code>.</p>
<dl class="section author"><dt>Autore</dt><dd>Alessandro Muntoni (<a href="#" onclick="location.href='mai'+'lto:'+'mun'+'to'+'ni.'+'al'+'ess'+'an'+'dro'+'@g'+'mai'+'l.'+'com'; return false;">munto<span style="display: none;">.nosp@m.</span>ni.a<span style="display: none;">.nosp@m.</span>lessa<span style="display: none;">.nosp@m.</span>ndro<span style="display: none;">.nosp@m.</span>@gmai<span style="display: none;">.nosp@m.</span>l.co<span style="display: none;">.nosp@m.</span>m</a>) </dd></dl>
</div><h2 class="groupheader">Documentazione dei costruttori e dei distruttori</h2>
<a id="a0ff512044e70664311a734ec8552a34b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ff512044e70664311a734ec8552a34b">&sect;&nbsp;</a></span>Face() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Dcel::Face::Face </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Costruttore di default. </p>
<p>Crea una faccia con:</p><ul>
<li>outer half edge settato a nullptr;</li>
<li>nessun inner half edge;</li>
<li>normale pari a (0, 0, 0);</li>
<li>area pari a 0;</li>
<li>id pari a 0;</li>
<li>flag pari a 0. </li>
</ul>

</div>
</div>
<a id="a81201ef173a9d61b54358c228fa94213"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81201ef173a9d61b54358c228fa94213">&sect;&nbsp;</a></span>Face() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Dcel::Face::Face </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *&#160;</td>
          <td class="paramname"><em>outer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Costruttore. </p>
<p>Crea una faccia con:</p><ul>
<li>outer half edge pari al parametro in input outer;</li>
<li>nessun inner half edge;</li>
<li>normale pari a (0, 0, 0);</li>
<li>area pari a 0;</li>
<li>id pari a 0;</li>
<li>flag pari a 0.</li>
</ul>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">outer</td><td>puntatore all'outer half edge settato alla faccia </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a110776298d887a6af85c9752ad83d21c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a110776298d887a6af85c9752ad83d21c">&sect;&nbsp;</a></span>Face() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Dcel::Face::Face </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *&#160;</td>
          <td class="paramname"><em>outer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>normal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Costruttore. </p>
<p>Crea una faccia con:</p><ul>
<li>outer half edge pari al parametro in input outer;</li>
<li>nessun inner half edge;</li>
<li>normale pari al parametro in input normal;</li>
<li>area pari a 0;</li>
<li>id pari a 0;</li>
<li>flag pari a 0;</li>
</ul>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">outer</td><td>puntatore all'outer half edge settato alla faccia </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">normal</td><td>vettore normale assegnato alla faccia </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6c5c081a14f17c8511b0d287c1a2a1ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c5c081a14f17c8511b0d287c1a2a1ab">&sect;&nbsp;</a></span>~Face()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Dcel::Face::~Face </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Distruttore vuoto. </p>
<p>La classe <a class="el" href="classDcel.html" title="Struttura dati Double Conntected Edge List. ">Dcel</a> dovrà occuparsi di eliminare tutti i riferimenti in essa contenuti (e quindi contenuti di conseguenza anche nella classe <a class="el" href="classDcel_1_1Face.html" title="Classe rappresentante una faccia della Dcel. ">Dcel::Face</a>). </p>

</div>
</div>
<h2 class="groupheader">Documentazione delle funzioni membro</h2>
<a id="a15e18b8354693674b78eab4af30c59ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15e18b8354693674b78eab4af30c59ff">&sect;&nbsp;</a></span>addInnerHalfEdge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Dcel::Face::addInnerHalfEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *&#160;</td>
          <td class="paramname"><em>newInnerHalfEdge</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Aggiunge un nuovo half edge di bordo interno (ossia un buco) alla faccia. </p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">newInnerHalfEdge</td><td>nuovo half edge di bordo interno aggiunto alla faccia </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af59364cf1dc84200e566d601b621d068"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af59364cf1dc84200e566d601b621d068">&sect;&nbsp;</a></span>getArea()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Dcel::Face::getArea </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restituisce la superficie della faccia. </p>
<dl class="section note"><dt>Nota</dt><dd>Non ricalcola l'area, restituisce solo l'ultima area calcolata o settata </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>L'area della faccia </dd></dl>

</div>
</div>
<a id="a2bd82f7a9cc0b888f7d06e650b25f4ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bd82f7a9cc0b888f7d06e650b25f4ce">&sect;&nbsp;</a></span>getBarycentre()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Pointd</a> Dcel::Face::getBarycentre </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calcola e restituisce il baricentro della faccia. </p>
<p>Il baricentro è calcolato come media dei vertici incidenti alla faccia.</p>
<dl class="section warning"><dt>Avvertimento</dt><dd>Utilizza <a class="el" href="classDcel_1_1Face_1_1ConstIncidentVertexIterator.html" title="Iteratore che permette di ciclare sui vertici incidenti ad una faccia, garantendone l&#39;immutabilità...">Dcel::Face::ConstIncidentVertexIterator</a> </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>Il baricentro della faccia. </dd></dl>

</div>
</div>
<a id="a3e67719f3a1ce31700730024cc2b9e9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e67719f3a1ce31700730024cc2b9e9c">&sect;&nbsp;</a></span>getColor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">QColor Dcel::Face::getColor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restituisce il colore associato alla faccia. </p>
<dl class="section return"><dt>Restituisce</dt><dd>Il colore della faccia </dd></dl>

</div>
</div>
<a id="aa0c471145b3175794eb4b04e06c4bb87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0c471145b3175794eb4b04e06c4bb87">&sect;&nbsp;</a></span>getFlag()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Dcel::Face::getFlag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restituisce il flag associato alla faccia. </p>
<dl class="section return"><dt>Restituisce</dt><dd>Il flag della faccia </dd></dl>

</div>
</div>
<a id="a31262c9a6006f4137f7f159b2d31e2aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31262c9a6006f4137f7f159b2d31e2aa">&sect;&nbsp;</a></span>getId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Dcel::Face::getId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restituisce l'id identificativo nella <a class="el" href="classDcel.html" title="Struttura dati Double Conntected Edge List. ">Dcel</a> della faccia. </p>
<dl class="section return"><dt>Restituisce</dt><dd>L'id della faccia </dd></dl>

</div>
</div>
<a id="a94395cd1222facb2d96c66c2a1b4192b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94395cd1222facb2d96c66c2a1b4192b">&sect;&nbsp;</a></span>getNormal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Vec3</a> Dcel::Face::getNormal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restituisce il vettore normale alla faccia. </p>
<dl class="section note"><dt>Nota</dt><dd>Non ricalcola la normale, restituisce solo l'ultima normale calcolata o settata </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>La normale della faccia </dd></dl>

</div>
</div>
<a id="a162d0e06202b30fe8e536d21dfbabf4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a162d0e06202b30fe8e536d21dfbabf4c">&sect;&nbsp;</a></span>getNumberIncidentHalfEdges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Dcel::Face::getNumberIncidentHalfEdges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Restituisce il numero di half edge incidenti alla faccia. </p>
<dl class="section warning"><dt>Avvertimento</dt><dd>Utilizza <a class="el" href="classDcel_1_1Face_1_1ConstIncidentHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge incidenti ad una faccia, garantendone l&#39;immutabilit...">Dcel::Face::ConstIncidentHalfEdgeIterator</a> </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>Il numero di half edge incidenti alla faccia </dd></dl>

</div>
</div>
<a id="aadb995d50381bba4dda1076bac42a85a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadb995d50381bba4dda1076bac42a85a">&sect;&nbsp;</a></span>getNumberIncidentVertices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Dcel::Face::getNumberIncidentVertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Restituisce il numero di vertici incidenti alla faccia. </p>
<dl class="section warning"><dt>Avvertimento</dt><dd>Utilizza <a class="el" href="classDcel_1_1Face_1_1ConstIncidentVertexIterator.html" title="Iteratore che permette di ciclare sui vertici incidenti ad una faccia, garantendone l&#39;immutabilità...">Dcel::Face::ConstIncidentVertexIterator</a> </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>Il numero di vertici incidenti alla faccia </dd></dl>

</div>
</div>
<a id="a4363d2e5d30672486cd6bbdf5a9e3f34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4363d2e5d30672486cd6bbdf5a9e3f34">&sect;&nbsp;</a></span>getNumberInnerHalfEdges()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Dcel::Face::getNumberInnerHalfEdges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restituisce il numero di inner half edges contenuti nella faccia, ossia il numero di buchi. </p>
<dl class="section return"><dt>Restituisce</dt><dd>Il numero di <a class="el" href="classDcel_1_1HalfEdge.html" title="Classe rappresentante un half edge della Dcel. ">HalfEdge</a> interni della faccia </dd></dl>

</div>
</div>
<a id="a4351e1633fb091b2190f9adf9f8ccfd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4351e1633fb091b2190f9adf9f8ccfd4">&sect;&nbsp;</a></span>getOuterHalfEdge() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> * Dcel::Face::getOuterHalfEdge </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restituisce il puntatore all'half edge costante di bordo esterno della faccia. </p>
<dl class="section return"><dt>Restituisce</dt><dd>L'<a class="el" href="classDcel_1_1HalfEdge.html" title="Classe rappresentante un half edge della Dcel. ">HalfEdge</a> di bordo della faccia </dd></dl>

</div>
</div>
<a id="a60b90e36a636a02e1701927953db635c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60b90e36a636a02e1701927953db635c">&sect;&nbsp;</a></span>getOuterHalfEdge() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> * Dcel::Face::getOuterHalfEdge </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restituisce il puntatore all'half edge di bordo esterno della faccia. </p>
<dl class="section return"><dt>Restituisce</dt><dd>L'<a class="el" href="classDcel_1_1HalfEdge.html" title="Classe rappresentante un half edge della Dcel. ">HalfEdge</a> di bordo della faccia </dd></dl>

</div>
</div>
<a id="a64f0b0cbebb36f7bab44b45c50b56d95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64f0b0cbebb36f7bab44b45c50b56d95">&sect;&nbsp;</a></span>hasHoles()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Dcel::Face::hasHoles </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restituisce true se la faccia contiene buchi. </p>
<dl class="section return"><dt>Restituisce</dt><dd>True se la faccia contiene buchi, false altrimenti </dd></dl>

</div>
</div>
<a id="a70bfb28e1852cadcb84bc865ebd688b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70bfb28e1852cadcb84bc865ebd688b0">&sect;&nbsp;</a></span>incidentHalfEdgeBegin() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Face_1_1ConstIncidentHalfEdgeIterator.html">Dcel::Face::ConstIncidentHalfEdgeIterator</a> Dcel::Face::incidentHalfEdgeBegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di inizializzazione di <a class="el" href="classDcel_1_1Face_1_1ConstIncidentHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge incidenti ad una faccia, garantendone l&#39;immutabilit...">Dcel::Face::ConstIncidentHalfEdgeIterator</a>. </p>
<p>Permette di ciclare sugli half edge incidenti alla faccia, partendo dall'outer half edge.</p>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore che punta all'outer half edge della faccia </dd></dl>

</div>
</div>
<a id="ad8aa4fe2aa6e7df2469a202157918f14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8aa4fe2aa6e7df2469a202157918f14">&sect;&nbsp;</a></span>incidentHalfEdgeBegin() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Face_1_1ConstIncidentHalfEdgeIterator.html">Dcel::Face::ConstIncidentHalfEdgeIterator</a> Dcel::Face::incidentHalfEdgeBegin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *&#160;</td>
          <td class="paramname"><em>start</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di inizializzazione di <a class="el" href="classDcel_1_1Face_1_1ConstIncidentHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge incidenti ad una faccia, garantendone l&#39;immutabilit...">Dcel::Face::ConstIncidentHalfEdgeIterator</a>. </p>
<p>Permette di ciclare sugli half edge incidenti alla faccia, partendo dall'half edge start.</p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>half edge di partenza </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Avvertimento</dt><dd>Se start non risulta essere incidente alla faccia, viene lanciata un'asserzione e il programma termina </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore che punta all'half edge start </dd></dl>

</div>
</div>
<a id="a4a95df38fec97e4583c1633b784bf60e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a95df38fec97e4583c1633b784bf60e">&sect;&nbsp;</a></span>incidentHalfEdgeBegin() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Face_1_1ConstIncidentHalfEdgeIterator.html">Dcel::Face::ConstIncidentHalfEdgeIterator</a> Dcel::Face::incidentHalfEdgeBegin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di inizializzazione di <a class="el" href="classDcel_1_1Face_1_1ConstIncidentHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge incidenti ad una faccia, garantendone l&#39;immutabilit...">Dcel::Face::ConstIncidentHalfEdgeIterator</a>. </p>
<p>Permette di ciclare sugli half edge incidenti alla faccia, partendo dall'half edge start e fino all'half edge end.</p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>half edge di partenza </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>half edge di arrivo, <b>non</b> <b>compreso</b> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Avvertimento</dt><dd>Se start e end non risultano essere incidenti alla faccia, viene lanciata un'asserzione e il programma termina </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore che punta all'half edge start </dd></dl>

</div>
</div>
<a id="a2e002b38ebdcf3afd7dbe1616392629a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e002b38ebdcf3afd7dbe1616392629a">&sect;&nbsp;</a></span>incidentHalfEdgeBegin() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Face_1_1IncidentHalfEdgeIterator.html">Dcel::Face::IncidentHalfEdgeIterator</a> Dcel::Face::incidentHalfEdgeBegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di inizializzazione di <a class="el" href="classDcel_1_1Face_1_1IncidentHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge incidenti ad una faccia. ">Dcel::Face::IncidentHalfEdgeIterator</a>. </p>
<p>Permette di ciclare sugli half edge incidenti alla faccia, partendo dall'outer half edge.</p>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore che punta all'outer half edge della faccia </dd></dl>

</div>
</div>
<a id="a2ebe49ba6d3e8b92b8b81876262166b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ebe49ba6d3e8b92b8b81876262166b8">&sect;&nbsp;</a></span>incidentHalfEdgeBegin() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Face_1_1IncidentHalfEdgeIterator.html">Dcel::Face::IncidentHalfEdgeIterator</a> Dcel::Face::incidentHalfEdgeBegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *&#160;</td>
          <td class="paramname"><em>start</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di inizializzazione di <a class="el" href="classDcel_1_1Face_1_1IncidentHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge incidenti ad una faccia. ">Dcel::Face::IncidentHalfEdgeIterator</a>. </p>
<p>Permette di ciclare sugli half edge incidenti alla faccia, partendo dall'half edge start.</p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>half edge di partenza </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Avvertimento</dt><dd>Se start non risulta essere incidente alla faccia, viene lanciata un'asserzione e il programma termina </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore che punta all'half edge start </dd></dl>

</div>
</div>
<a id="a6951f450fae7c4f9df8e5e269249d68e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6951f450fae7c4f9df8e5e269249d68e">&sect;&nbsp;</a></span>incidentHalfEdgeBegin() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Face_1_1IncidentHalfEdgeIterator.html">Dcel::Face::IncidentHalfEdgeIterator</a> Dcel::Face::incidentHalfEdgeBegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di inizializzazione di <a class="el" href="classDcel_1_1Face_1_1IncidentHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge incidenti ad una faccia. ">Dcel::Face::IncidentHalfEdgeIterator</a>. </p>
<p>Permette di ciclare sugli half edge incidenti alla faccia, partendo dall'half edge start e fino all'half edge end.</p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>half edge di partenza </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>half edge di arrivo, <b>non</b> <b>compreso</b> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Avvertimento</dt><dd>Se start e end non risultano essere incidenti alla faccia, viene lanciata un'asserzione e il programma termina </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore che punta all'half edge start </dd></dl>

</div>
</div>
<a id="a0c7a4d4d5643fdf6df7806483f12fffa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c7a4d4d5643fdf6df7806483f12fffa">&sect;&nbsp;</a></span>incidentHalfEdgeEnd() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Face_1_1ConstIncidentHalfEdgeIterator.html">Dcel::Face::ConstIncidentHalfEdgeIterator</a> Dcel::Face::incidentHalfEdgeEnd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di finalizzazione di <a class="el" href="classDcel_1_1Face_1_1ConstIncidentHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge incidenti ad una faccia, garantendone l&#39;immutabilit...">Dcel::Face::ConstIncidentHalfEdgeIterator</a>. </p>
<dl class="section warning"><dt>Avvertimento</dt><dd>L'iteratore restituito non è un iteratore valido, e su di esso le operazioni di incremento e decremento sono inutili. Questa funzione è da utilizzarsi solamente per il <b>confronto</b> <b>con</b> <b>un</b> <b>altro</b> <b>iteratore</b> <b>valido</b> </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore di finalizzazione </dd></dl>

</div>
</div>
<a id="a688a3ed79f2081ce079b272fd9ca29cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a688a3ed79f2081ce079b272fd9ca29cb">&sect;&nbsp;</a></span>incidentHalfEdgeEnd() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Face_1_1IncidentHalfEdgeIterator.html">Dcel::Face::IncidentHalfEdgeIterator</a> Dcel::Face::incidentHalfEdgeEnd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di finalizzazione di <a class="el" href="classDcel_1_1Face_1_1IncidentHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge incidenti ad una faccia. ">Dcel::Face::IncidentHalfEdgeIterator</a>. </p>
<dl class="section warning"><dt>Avvertimento</dt><dd>L'iteratore restituito non è un iteratore valido, e su di esso le operazioni di incremento e decremento sono inutili. Questa funzione è da utilizzarsi solamente per il <b>confronto</b> <b>con</b> <b>un</b> <b>altro</b> <b>iteratore</b> <b>valido</b> </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore di finalizzazione </dd></dl>

</div>
</div>
<a id="aa151c9c356a3ecc755a4e171d65641da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa151c9c356a3ecc755a4e171d65641da">&sect;&nbsp;</a></span>incidentVertexBegin() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Face_1_1ConstIncidentVertexIterator.html">Dcel::Face::ConstIncidentVertexIterator</a> Dcel::Face::incidentVertexBegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di inizializzazione di <a class="el" href="classDcel_1_1Face_1_1ConstIncidentVertexIterator.html" title="Iteratore che permette di ciclare sui vertici incidenti ad una faccia, garantendone l&#39;immutabilità...">Dcel::Face::ConstIncidentVertexIterator</a>. </p>
<p>Permette di ciclare sui vertici incidenti alla faccia, partendo dal toVertex dell'outer half edge.</p>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore che punta al toVertex dell'outer half edge della faccia </dd></dl>

</div>
</div>
<a id="a77e6420bf3bc21e9dd6ba00e54a5412b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77e6420bf3bc21e9dd6ba00e54a5412b">&sect;&nbsp;</a></span>incidentVertexBegin() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Face_1_1ConstIncidentVertexIterator.html">Dcel::Face::ConstIncidentVertexIterator</a> Dcel::Face::incidentVertexBegin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *&#160;</td>
          <td class="paramname"><em>start</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di inizializzazione di <a class="el" href="classDcel_1_1Face_1_1ConstIncidentVertexIterator.html" title="Iteratore che permette di ciclare sui vertici incidenti ad una faccia, garantendone l&#39;immutabilità...">Dcel::Face::ConstIncidentVertexIterator</a>. </p>
<p>Permette di ciclare sui vertici incidenti alla faccia, partendo dal toVertex dell'half edge start.</p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>half edge di partenza </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Avvertimento</dt><dd>Se start non risulta essere incidente alla faccia, viene lanciata un'asserzione e il programma termina </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore che punta al toVertex dell'half edge start </dd></dl>

</div>
</div>
<a id="ac1a7f528f3fff84561144e25eff9b79a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1a7f528f3fff84561144e25eff9b79a">&sect;&nbsp;</a></span>incidentVertexBegin() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Face_1_1ConstIncidentVertexIterator.html">Dcel::Face::ConstIncidentVertexIterator</a> Dcel::Face::incidentVertexBegin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di inizializzazione di <a class="el" href="classDcel_1_1Face_1_1ConstIncidentVertexIterator.html" title="Iteratore che permette di ciclare sui vertici incidenti ad una faccia, garantendone l&#39;immutabilità...">Dcel::Face::ConstIncidentVertexIterator</a>. </p>
<p>Permette di ciclare sui vertici incidenti alla faccia, partendo dal toVertex dell'half edge start e fino al toVertex dell'half edge end.</p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>half edge di partenza </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>half edge di arrivo, il cui toVertex <b>non</b> <b>è</b> <b>compreso</b> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Avvertimento</dt><dd>Se start e end non risultano essere incidenti alla faccia, viene lanciata un'asserzione e il programma termina </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore che punta al toVertex dell'half edge start </dd></dl>

</div>
</div>
<a id="ade7ea1ce7355caab78a50ab950e3dc4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade7ea1ce7355caab78a50ab950e3dc4a">&sect;&nbsp;</a></span>incidentVertexBegin() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Face_1_1ConstIncidentVertexIterator.html">Dcel::Face::ConstIncidentVertexIterator</a> Dcel::Face::incidentVertexBegin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDcel_1_1Vertex.html">Dcel::Vertex</a> *&#160;</td>
          <td class="paramname"><em>start</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di inizializzazione di <a class="el" href="classDcel_1_1Face_1_1ConstIncidentVertexIterator.html" title="Iteratore che permette di ciclare sui vertici incidenti ad una faccia, garantendone l&#39;immutabilità...">Dcel::Face::ConstIncidentVertexIterator</a>. </p>
<p>Permette di ciclare sui vertici incidenti alla faccia, partendo dal vertice start. <br />
È meno efficiente rispetto a Dcel::Face::constIncidentVertexBegin(const Dcel::HalfEdge* start).</p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>vertice di partenza </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Avvertimento</dt><dd>Se start non risulta essere incidente alla faccia (ossia non possiede un half edge incidente alla faccia), viene lanciata un'asserzione e il programma termina </dd>
<dd>
Utilizza <a class="el" href="classDcel_1_1Vertex_1_1ConstIncomingHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge entranti in un vertice, garantendone l&#39;immutabilità...">Dcel::Vertex::ConstIncomingHalfEdgeIterator</a> </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore che punta al vertice start </dd></dl>

</div>
</div>
<a id="ae532c7fce4523b34c103c6a22d0b5726"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae532c7fce4523b34c103c6a22d0b5726">&sect;&nbsp;</a></span>incidentVertexBegin() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Face_1_1ConstIncidentVertexIterator.html">Dcel::Face::ConstIncidentVertexIterator</a> Dcel::Face::incidentVertexBegin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDcel_1_1Vertex.html">Dcel::Vertex</a> *&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDcel_1_1Vertex.html">Dcel::Vertex</a> *&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di inizializzazione di <a class="el" href="classDcel_1_1Face_1_1ConstIncidentVertexIterator.html" title="Iteratore che permette di ciclare sui vertici incidenti ad una faccia, garantendone l&#39;immutabilità...">Dcel::Face::ConstIncidentVertexIterator</a>. </p>
<p>Permette di ciclare sui vertici incidenti alla faccia, partendo dal vertice start e fino al vertice end. <br />
È meno efficiente rispetto a Dcel::Face::constIncidentVertexBegin(const Dcel::HalfEdge* start, const Dcel::HalfEdge* end).</p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>vertice di partenza </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>vertice di arrivo, <b>non</b> <b>compreso</b> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Avvertimento</dt><dd>Se start e end non risultano essere incidenti alla faccia (ossia non possiedono un half edge incidente alla faccia), viene lanciata un'asserzione e il programma termina </dd>
<dd>
Utilizza <a class="el" href="classDcel_1_1Vertex_1_1ConstIncomingHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge entranti in un vertice, garantendone l&#39;immutabilità...">Dcel::Vertex::ConstIncomingHalfEdgeIterator</a> </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore che punta al vertice start </dd></dl>

</div>
</div>
<a id="a86773f03bf18efdf0b2b194d7395d76c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86773f03bf18efdf0b2b194d7395d76c">&sect;&nbsp;</a></span>incidentVertexBegin() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Face_1_1IncidentVertexIterator.html">Dcel::Face::IncidentVertexIterator</a> Dcel::Face::incidentVertexBegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di inizializzazione di <a class="el" href="classDcel_1_1Face_1_1IncidentVertexIterator.html" title="Iteratore che permette di ciclare sui vertici incidenti ad una faccia. ">Dcel::Face::IncidentVertexIterator</a>. </p>
<p>Permette di ciclare sui vertici incidenti alla faccia, partendo dal toVertex dell'outer half edge.</p>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore che punta al toVertex dell'outer half edge della faccia </dd></dl>

</div>
</div>
<a id="adfde89779c3cd1ceec15cc0600205709"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfde89779c3cd1ceec15cc0600205709">&sect;&nbsp;</a></span>incidentVertexBegin() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Face_1_1IncidentVertexIterator.html">Dcel::Face::IncidentVertexIterator</a> Dcel::Face::incidentVertexBegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *&#160;</td>
          <td class="paramname"><em>start</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di inizializzazione di <a class="el" href="classDcel_1_1Face_1_1IncidentVertexIterator.html" title="Iteratore che permette di ciclare sui vertici incidenti ad una faccia. ">Dcel::Face::IncidentVertexIterator</a>. </p>
<p>Permette di ciclare sui vertici incidenti alla faccia, partendo dal toVertex dell'half edge start.</p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>half edge di partenza </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Avvertimento</dt><dd>Se start non risulta essere incidente alla faccia, viene lanciata un'asserzione e il programma termina </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore che punta al toVertex dell'half edge start </dd></dl>

</div>
</div>
<a id="a9be21806cfd3db916d2e69c98a55ce19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9be21806cfd3db916d2e69c98a55ce19">&sect;&nbsp;</a></span>incidentVertexBegin() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Face_1_1IncidentVertexIterator.html">Dcel::Face::IncidentVertexIterator</a> Dcel::Face::incidentVertexBegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di inizializzazione di <a class="el" href="classDcel_1_1Face_1_1IncidentVertexIterator.html" title="Iteratore che permette di ciclare sui vertici incidenti ad una faccia. ">Dcel::Face::IncidentVertexIterator</a>. </p>
<p>Permette di ciclare sui vertici incidenti alla faccia, partendo dal toVertex dell'half edge start e fino al toVertex dell'half edge end.</p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>half edge di partenza </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>half edge di arrivo, il cui toVertex <b>non</b> <b>è</b> <b>compreso</b> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Avvertimento</dt><dd>Se start e end non risultano essere incidenti alla faccia, viene lanciata un'asserzione e il programma termina </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore che punta al toVertex dell'half edge start </dd></dl>

</div>
</div>
<a id="a509cd6d27a881bbb262bc57b50d72e9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a509cd6d27a881bbb262bc57b50d72e9d">&sect;&nbsp;</a></span>incidentVertexBegin() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Face_1_1IncidentVertexIterator.html">Dcel::Face::IncidentVertexIterator</a> Dcel::Face::incidentVertexBegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDcel_1_1Vertex.html">Dcel::Vertex</a> *&#160;</td>
          <td class="paramname"><em>start</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di inizializzazione di <a class="el" href="classDcel_1_1Face_1_1IncidentVertexIterator.html" title="Iteratore che permette di ciclare sui vertici incidenti ad una faccia. ">Dcel::Face::IncidentVertexIterator</a>. </p>
<p>Permette di ciclare sui vertici incidenti alla faccia, partendo dal vertice start. <br />
È meno efficiente rispetto a Dcel::Face::incidentVertexBegin(const Dcel::HalfEdge* start).</p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>vertice di partenza </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Avvertimento</dt><dd>Se start non risulta essere incidente alla faccia (ossia non possiede un half edge incidente alla faccia), viene lanciata un'asserzione e il programma termina </dd>
<dd>
Utilizza <a class="el" href="classDcel_1_1Vertex_1_1ConstIncomingHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge entranti in un vertice, garantendone l&#39;immutabilità...">Dcel::Vertex::ConstIncomingHalfEdgeIterator</a> </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore che punta al vertice start </dd></dl>

</div>
</div>
<a id="a070c7fe2e49e189a09da67143ffdac51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a070c7fe2e49e189a09da67143ffdac51">&sect;&nbsp;</a></span>incidentVertexBegin() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Face_1_1IncidentVertexIterator.html">Dcel::Face::IncidentVertexIterator</a> Dcel::Face::incidentVertexBegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDcel_1_1Vertex.html">Dcel::Vertex</a> *&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDcel_1_1Vertex.html">Dcel::Vertex</a> *&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di inizializzazione di <a class="el" href="classDcel_1_1Face_1_1IncidentVertexIterator.html" title="Iteratore che permette di ciclare sui vertici incidenti ad una faccia. ">Dcel::Face::IncidentVertexIterator</a>. </p>
<p>Permette di ciclare sui vertici incidenti alla faccia, partendo dal vertice start e fino al vertice end. <br />
È meno efficiente rispetto a Dcel::Face::incidentVertexBegin(const Dcel::HalfEdge* start, const Dcel::HalfEdge* end).</p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>vertice di partenza </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>vertice di arrivo, <b>non</b> <b>compreso</b> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Avvertimento</dt><dd>Se start e end non risultano essere incidenti alla faccia (ossia non possiedono un half edge incidente alla faccia), viene lanciata un'asserzione e il programma termina </dd>
<dd>
Utilizza <a class="el" href="classDcel_1_1Vertex_1_1ConstIncomingHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge entranti in un vertice, garantendone l&#39;immutabilità...">Dcel::Vertex::ConstIncomingHalfEdgeIterator</a> </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore che punta al vertice start </dd></dl>

</div>
</div>
<a id="a8daecf496c56a8eb3ea9dee6e167abc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8daecf496c56a8eb3ea9dee6e167abc8">&sect;&nbsp;</a></span>incidentVertexEnd() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Face_1_1ConstIncidentVertexIterator.html">Dcel::Face::ConstIncidentVertexIterator</a> Dcel::Face::incidentVertexEnd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di finalizzazione di <a class="el" href="classDcel_1_1Face_1_1ConstIncidentVertexIterator.html" title="Iteratore che permette di ciclare sui vertici incidenti ad una faccia, garantendone l&#39;immutabilità...">Dcel::Face::ConstIncidentVertexIterator</a>. </p>
<dl class="section warning"><dt>Avvertimento</dt><dd>L'iteratore restituito non è un iteratore valido, e su di esso le operazioni di incremento e decremento sono inutili. Questa funzione è da utilizzarsi solamente per il <b>confronto</b> <b>con</b> <b>un</b> <b>altro</b> <b>iteratore</b> <b>valido</b> </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore di finalizzazione </dd></dl>

</div>
</div>
<a id="a19f53077b101635685bb82efd225789e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19f53077b101635685bb82efd225789e">&sect;&nbsp;</a></span>incidentVertexEnd() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Face_1_1IncidentVertexIterator.html">Dcel::Face::IncidentVertexIterator</a> Dcel::Face::incidentVertexEnd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di finalizzazione di <a class="el" href="classDcel_1_1Face_1_1IncidentVertexIterator.html" title="Iteratore che permette di ciclare sui vertici incidenti ad una faccia. ">Dcel::Face::IncidentVertexIterator</a>. </p>
<dl class="section warning"><dt>Avvertimento</dt><dd>L'iteratore restituito non è un iteratore valido, e su di esso le operazioni di incremento e decremento sono inutili. Questa funzione è da utilizzarsi solamente per il <b>confronto</b> <b>con</b> <b>un</b> <b>altro</b> <b>iteratore</b> <b>valido</b> </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore di finalizzazione </dd></dl>

</div>
</div>
<a id="a552fcf6add14c42c61d3959417d5ebe9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a552fcf6add14c42c61d3959417d5ebe9">&sect;&nbsp;</a></span>innerComponentsToString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string Dcel::Face::innerComponentsToString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Funzione che restituisce una stringa degli inner half edge. </p>
<dl class="section return"><dt>Restituisce</dt><dd>Una stringa rappresentativa degli inner half edge della faccia </dd></dl>

</div>
</div>
<a id="ae658f73323ae563c330d276c4d712235"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae658f73323ae563c330d276c4d712235">&sect;&nbsp;</a></span>innerHalfEdgeBegin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Face_1_1ConstInnerHalfEdgeIterator.html">Dcel::Face::ConstInnerHalfEdgeIterator</a> Dcel::Face::innerHalfEdgeBegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di inizializzazione di <a class="el" href="classDcel_1_1Face_1_1ConstInnerHalfEdgeIterator.html" title="Iteratore che permette di ciclare sul vettore degli inner half edge associati alla faccia...">Dcel::Face::ConstInnerHalfEdgeIterator</a>. </p>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore che punta al primo inner half edge della faccia </dd></dl>

</div>
</div>
<a id="a561aff52c205ceb05b6fc5d57850a4f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a561aff52c205ceb05b6fc5d57850a4f7">&sect;&nbsp;</a></span>innerHalfEdgeBegin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Dcel::Face::InnerHalfEdgeIterator Dcel::Face::innerHalfEdgeBegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di inizializzazione di Dcel::Face::InnerHalfEdgeIterator. </p>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore che punta al primo inner half edge della faccia </dd></dl>

</div>
</div>
<a id="a07a015358abb89178a3e74e337706cab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07a015358abb89178a3e74e337706cab">&sect;&nbsp;</a></span>innerHalfEdgeEnd() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Face_1_1ConstInnerHalfEdgeIterator.html">Dcel::Face::ConstInnerHalfEdgeIterator</a> Dcel::Face::innerHalfEdgeEnd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di finalizzazione di <a class="el" href="classDcel_1_1Face_1_1ConstInnerHalfEdgeIterator.html" title="Iteratore che permette di ciclare sul vettore degli inner half edge associati alla faccia...">Dcel::Face::ConstInnerHalfEdgeIterator</a>. </p>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore che punta all'ultimo inner half edge della faccia </dd></dl>

</div>
</div>
<a id="a737316644d40e7157f3c6cd90eb7853e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a737316644d40e7157f3c6cd90eb7853e">&sect;&nbsp;</a></span>innerHalfEdgeEnd() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Dcel::Face::InnerHalfEdgeIterator Dcel::Face::innerHalfEdgeEnd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di finalizzazione di Dcel::Face::InnerHalfEdgeIterator. </p>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore che punta all'ultimo inner half edge della faccia </dd></dl>

</div>
</div>
<a id="a0ba07291a4a48adefbd52b3e25b99335"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ba07291a4a48adefbd52b3e25b99335">&sect;&nbsp;</a></span>isTriangle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Dcel::Face::isTriangle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione che verifica se la faccia è un triangolo. </p>
<dl class="section warning"><dt>Avvertimento</dt><dd>utilizza <a class="el" href="classDcel_1_1Face_1_1ConstIncidentVertexIterator.html" title="Iteratore che permette di ciclare sui vertici incidenti ad una faccia, garantendone l&#39;immutabilità...">Dcel::Face::ConstIncidentVertexIterator</a> </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>True se la faccia è un triangolo, false altrimenti </dd></dl>

</div>
</div>
<a id="a1c5678187ef14564ae9995bacb14c711"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c5678187ef14564ae9995bacb14c711">&sect;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Dcel::Face::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDcel_1_1Face.html">Face</a> &amp;&#160;</td>
          <td class="paramname"><em>otherFace</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Operatore di disuguaglianza tra facce. </p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">otherFace</td><td>faccia con cui verrà verificata la disuguaglianza con la faccia this </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Restituisce</dt><dd>True se le facce sono diverse, false altrimenti </dd></dl>

</div>
</div>
<a id="a279ff3a8968f503bc74a84458ff909a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a279ff3a8968f503bc74a84458ff909a4">&sect;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Dcel::Face::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDcel_1_1Face.html">Face</a> &amp;&#160;</td>
          <td class="paramname"><em>otherFace</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Operatore di uguaglianza tra facce. </p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">otherFace</td><td>faccia con cui verrà verificata l'uguaglianza con la faccia this </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Restituisce</dt><dd>True se le facce sono uguali, false altrimenti </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000002">Da fare:</a></b></dt><dd>Da riscrivere </dd></dl>

</div>
</div>
<a id="a9c86481d66af33c6c89c886d039d0a85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c86481d66af33c6c89c886d039d0a85">&sect;&nbsp;</a></span>removeInnerHalfEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Dcel::Face::removeInnerHalfEdge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *&#160;</td>
          <td class="paramname"><em>halfEdge</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione che rimuove un inner half edge dalla faccia. </p>
<p>È meno efficiente rispetto a Dcel::Face::removeInnerHalfEdge(const Face::innerHalfEdgeIterator &amp;ihe).</p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">halfEdge</td><td>inner half edge da eliminare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Restituisce</dt><dd>True se la rimozione è andata a buon fine, false altrimenti. </dd></dl>

</div>
</div>
<a id="a02676459ce353dba0b0983911268ff96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02676459ce353dba0b0983911268ff96">&sect;&nbsp;</a></span>setArea()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Dcel::Face::setArea </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>newArea</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Setta la superficie della faccia. </p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">newArea</td><td>il valore dell'area che verrà settato </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a622a92cad8c5ee5fa973e96e9b5a0421"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a622a92cad8c5ee5fa973e96e9b5a0421">&sect;&nbsp;</a></span>setColor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Dcel::Face::setColor </td>
          <td>(</td>
          <td class="paramtype">const QColor &amp;&#160;</td>
          <td class="paramname"><em>newColor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assegna un nuovo colore alla faccia. </p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">newColor</td><td>il nuovo colore che verrà assegnato alla faccia </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa604cccda19f4c3a1de587b821e7a30a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa604cccda19f4c3a1de587b821e7a30a">&sect;&nbsp;</a></span>setFlag()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Dcel::Face::setFlag </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>newFlag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Setta il flag della faccia. </p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">newFlag</td><td>il valore del flag che verrà settato </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3b1af1643612348b740552f4eb90a476"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b1af1643612348b740552f4eb90a476">&sect;&nbsp;</a></span>setId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Dcel::Face::setId </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Setta l'id della faccia. </p>
<p>Questa funzione dovrebbe essere chiamata solamente dalla classe <a class="el" href="classDcel.html" title="Struttura dati Double Conntected Edge List. ">Dcel</a>.</p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>nuovo id che verrà assegnato alla faccia </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7b44bed402a0bf5ab57203408dab1848"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b44bed402a0bf5ab57203408dab1848">&sect;&nbsp;</a></span>setNormal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Dcel::Face::setNormal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>newNormal</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Setta il vettore normale della faccia. </p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">newNormal</td><td>il vettore normale che verrà settato </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af14047c54344631b42bf5a7758ade2a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af14047c54344631b42bf5a7758ade2a7">&sect;&nbsp;</a></span>setOuterHalfEdge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Dcel::Face::setOuterHalfEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *&#160;</td>
          <td class="paramname"><em>newOuterHalfEdge</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assegna un nuovo half edge di bordo esterno alla faccia. </p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">newOuterHalfEdge</td><td>puntatore all'half edge di bordo esterno assegnato alla faccia </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab83c5c47cd7c97c6c9182b586642fff2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab83c5c47cd7c97c6c9182b586642fff2">&sect;&nbsp;</a></span>toString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Dcel::Face::toString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione toString di una faccia. </p>
<dl class="section return"><dt>Restituisce</dt><dd>Una stringa rappresentativa della faccia </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000001">Da fare:</a></b></dt><dd>Da aggiornare </dd></dl>

</div>
</div>
<a id="ae9dc660372a1981c9dc23268be6deea3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9dc660372a1981c9dc23268be6deea3">&sect;&nbsp;</a></span>updateArea()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float Dcel::Face::updateArea </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione che aggiorna l'area della faccia. </p>
<dl class="section warning"><dt>Avvertimento</dt><dd>Funziona se e solo se la faccia è un triangolo </dd>
<dd>
Utilizza <a class="el" href="classDcel_1_1Face_1_1ConstIncidentVertexIterator.html" title="Iteratore che permette di ciclare sui vertici incidenti ad una faccia, garantendone l&#39;immutabilità...">Dcel::Face::ConstIncidentVertexIterator</a> </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>L'area della faccia aggiornata </dd></dl>

</div>
</div>
<a id="a4ad77590c260b153376cf06b8b1edad8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ad77590c260b153376cf06b8b1edad8">&sect;&nbsp;</a></span>updateNormal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Vec3</a> Dcel::Face::updateNormal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione che aggiorna la normale alla faccia. </p>
<dl class="section warning"><dt>Avvertimento</dt><dd>Funziona se e solo se la faccia è un triangolo </dd>
<dd>
Utilizza <a class="el" href="classDcel_1_1Face_1_1ConstIncidentVertexIterator.html" title="Iteratore che permette di ciclare sui vertici incidenti ad una faccia, garantendone l&#39;immutabilità...">Dcel::Face::ConstIncidentVertexIterator</a> </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>La normale alla faccia aggiornata </dd></dl>

</div>
</div>
<hr/>La documentazione per questa classe è stata generata a partire dai seguenti file:<ul>
<li><a class="el" href="dcel__face_8h_source.html">dcel_face.h</a></li>
<li>dcel_face.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classDcel.html">Dcel</a></li><li class="navelem"><a class="el" href="classDcel_1_1Face.html">Face</a></li>
    <li class="footer">Generato da
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.12 </li>
  </ul>
</div>
</body>
</html>
