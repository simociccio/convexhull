<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Dcel Data Structure: Riferimenti per la classe Dcel::Vertex</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Dcel Data Structure
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generato da Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Cerca');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Cerca');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classDcel_1_1Vertex.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Composti</a> &#124;
<a href="#pub-methods">Membri pubblici</a> &#124;
<a href="#pro-methods">Membri protetti</a> &#124;
<a href="#pro-attribs">Attributi protetti</a> &#124;
<a href="#friends">Friend</a> &#124;
<a href="classDcel_1_1Vertex-members.html">Elenco di tutti i membri</a>  </div>
  <div class="headertitle">
<div class="title">Riferimenti per la classe Dcel::Vertex</div>  </div>
</div><!--header-->
<div class="contents">

<p>Classe rappresentante un vertice della DCEL.  
 <a href="classDcel_1_1Vertex.html#details">Continua...</a></p>

<p><code>#include &lt;<a class="el" href="dcel__vertex_8h_source.html">dcel_vertex.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Composti</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex_1_1AdjacentVertexIterator.html">AdjacentVertexIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iteratore che permette di ciclare sui vertici adiacenti ad un vertice.  <a href="classDcel_1_1Vertex_1_1AdjacentVertexIterator.html#details">Continua...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex_1_1ConstAdjacentVertexIterator.html">ConstAdjacentVertexIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iteratore che permette di ciclare sui vertici adiacenti ad un vertice, garantendone l'immutabilità.  <a href="classDcel_1_1Vertex_1_1ConstAdjacentVertexIterator.html#details">Continua...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex_1_1ConstIncidentFaceIterator.html">ConstIncidentFaceIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iteratore che permette di ciclare sulle facce incidenti su un vertice.  <a href="classDcel_1_1Vertex_1_1ConstIncidentFaceIterator.html#details">Continua...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex_1_1ConstIncidentHalfEdgeIterator.html">ConstIncidentHalfEdgeIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iteratore che permette di ciclare sugli half edge uscenti e entranti in un vertice.  <a href="classDcel_1_1Vertex_1_1ConstIncidentHalfEdgeIterator.html#details">Continua...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex_1_1ConstIncomingHalfEdgeIterator.html">ConstIncomingHalfEdgeIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iteratore che permette di ciclare sugli half edge entranti in un vertice, garantendone l'immutabilità.  <a href="classDcel_1_1Vertex_1_1ConstIncomingHalfEdgeIterator.html#details">Continua...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex_1_1ConstOutgoingHalfEdgeIterator.html">ConstOutgoingHalfEdgeIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iteratore che permette di ciclare sugli half edge uscenti da un vertice, garantendone l'immutabilità.  <a href="classDcel_1_1Vertex_1_1ConstOutgoingHalfEdgeIterator.html#details">Continua...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex_1_1IncidentFaceIterator.html">IncidentFaceIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iteratore che permette di ciclare sulle facce incidenti su un vertice.  <a href="classDcel_1_1Vertex_1_1IncidentFaceIterator.html#details">Continua...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex_1_1IncidentHalfEdgeIterator.html">IncidentHalfEdgeIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iteratore che permette di ciclare sugli half edge uscenti e entranti in un vertice.  <a href="classDcel_1_1Vertex_1_1IncidentHalfEdgeIterator.html#details">Continua...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex_1_1IncomingHalfEdgeIterator.html">IncomingHalfEdgeIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iteratore che permette di ciclare sugli half edge entranti in un vertice.  <a href="classDcel_1_1Vertex_1_1IncomingHalfEdgeIterator.html#details">Continua...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex_1_1OutgoingHalfEdgeIterator.html">OutgoingHalfEdgeIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iteratore che permette di ciclare sugli half edge uscenti da un vertice.  <a href="classDcel_1_1Vertex_1_1OutgoingHalfEdgeIterator.html#details">Continua...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Membri pubblici</h2></td></tr>
<tr class="memitem:a2da229e7ef9443810ec4f61da9a33e76"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#a2da229e7ef9443810ec4f61da9a33e76">Vertex</a> ()</td></tr>
<tr class="memdesc:a2da229e7ef9443810ec4f61da9a33e76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Costruttore di default.  <a href="#a2da229e7ef9443810ec4f61da9a33e76">Continua...</a><br /></td></tr>
<tr class="separator:a2da229e7ef9443810ec4f61da9a33e76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3da5e567cfaf3d1d4c9a3dfecf13564"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#ad3da5e567cfaf3d1d4c9a3dfecf13564">Vertex</a> (const <a class="el" href="classPoint.html">Pointd</a> &amp;p)</td></tr>
<tr class="memdesc:ad3da5e567cfaf3d1d4c9a3dfecf13564"><td class="mdescLeft">&#160;</td><td class="mdescRight">Costruttore di default.  <a href="#ad3da5e567cfaf3d1d4c9a3dfecf13564">Continua...</a><br /></td></tr>
<tr class="separator:ad3da5e567cfaf3d1d4c9a3dfecf13564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31aaedc4b3477ed85390daa341f3976e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#a31aaedc4b3477ed85390daa341f3976e">Vertex</a> (const <a class="el" href="classPoint.html">Pointd</a> &amp;p, <a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *halfEdge)</td></tr>
<tr class="memdesc:a31aaedc4b3477ed85390daa341f3976e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Costruttore di default.  <a href="#a31aaedc4b3477ed85390daa341f3976e">Continua...</a><br /></td></tr>
<tr class="separator:a31aaedc4b3477ed85390daa341f3976e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58eb006d5da7901f5cbc5f103e919a0f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#a58eb006d5da7901f5cbc5f103e919a0f">Vertex</a> (const <a class="el" href="classPoint.html">Pointd</a> &amp;p, <a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *halfEdge, int <a class="el" href="classDcel_1_1Vertex.html#a532c8cd4a47dc77aa49142d74024a964">cardinality</a>)</td></tr>
<tr class="memdesc:a58eb006d5da7901f5cbc5f103e919a0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Costruttore di default.  <a href="#a58eb006d5da7901f5cbc5f103e919a0f">Continua...</a><br /></td></tr>
<tr class="separator:a58eb006d5da7901f5cbc5f103e919a0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f736bd9320adb06315ba1c7a12f1f87"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#a3f736bd9320adb06315ba1c7a12f1f87">~Vertex</a> ()</td></tr>
<tr class="memdesc:a3f736bd9320adb06315ba1c7a12f1f87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Distruttore vuoto.  <a href="#a3f736bd9320adb06315ba1c7a12f1f87">Continua...</a><br /></td></tr>
<tr class="separator:a3f736bd9320adb06315ba1c7a12f1f87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad37cd4f73b74fb445dfde68ec28e8dff"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#ad37cd4f73b74fb445dfde68ec28e8dff">getId</a> () const</td></tr>
<tr class="memdesc:ad37cd4f73b74fb445dfde68ec28e8dff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restirìtuisce l'id identificativo nella <a class="el" href="classDcel.html" title="Struttura dati Double Conntected Edge List. ">Dcel</a> del vertice.  <a href="#ad37cd4f73b74fb445dfde68ec28e8dff">Continua...</a><br /></td></tr>
<tr class="separator:ad37cd4f73b74fb445dfde68ec28e8dff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2959403f49c0e290ac9089429d5138b5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#a2959403f49c0e290ac9089429d5138b5">getFlag</a> () const</td></tr>
<tr class="memdesc:a2959403f49c0e290ac9089429d5138b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restituisce il flag associato al vertice.  <a href="#a2959403f49c0e290ac9089429d5138b5">Continua...</a><br /></td></tr>
<tr class="separator:a2959403f49c0e290ac9089429d5138b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab12daad67777575b0cd7aa734a5e72e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#ab12daad67777575b0cd7aa734a5e72e8">getNormal</a> () const</td></tr>
<tr class="memdesc:ab12daad67777575b0cd7aa734a5e72e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restituisce il vettore normale al vertice.  <a href="#ab12daad67777575b0cd7aa734a5e72e8">Continua...</a><br /></td></tr>
<tr class="separator:ab12daad67777575b0cd7aa734a5e72e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada77901c0ffb081ea5799e0a25e47b50"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Pointd</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#ada77901c0ffb081ea5799e0a25e47b50">getCoordinate</a> () const</td></tr>
<tr class="memdesc:ada77901c0ffb081ea5799e0a25e47b50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restituisce le coordinate del vertice.  <a href="#ada77901c0ffb081ea5799e0a25e47b50">Continua...</a><br /></td></tr>
<tr class="separator:ada77901c0ffb081ea5799e0a25e47b50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac117e101196d703a3004319171b36c3f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#ac117e101196d703a3004319171b36c3f">getCardinality</a> () const</td></tr>
<tr class="memdesc:ac117e101196d703a3004319171b36c3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restituisce il numero di edge incidenti sul vertice.  <a href="#ac117e101196d703a3004319171b36c3f">Continua...</a><br /></td></tr>
<tr class="separator:ac117e101196d703a3004319171b36c3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f9c69fd35ed7350f28cacf7606e8181"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#a5f9c69fd35ed7350f28cacf7606e8181">getIncidentHalfEdge</a> () const</td></tr>
<tr class="memdesc:a5f9c69fd35ed7350f28cacf7606e8181"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restituisce il puntatore l'half edge costante incidente sul vertice.  <a href="#a5f9c69fd35ed7350f28cacf7606e8181">Continua...</a><br /></td></tr>
<tr class="separator:a5f9c69fd35ed7350f28cacf7606e8181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeea51e1990497f38a468637f2e62ff72"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#aeea51e1990497f38a468637f2e62ff72">dist</a> (const <a class="el" href="classDcel_1_1Vertex.html">Dcel::Vertex</a> *otherVertex) const</td></tr>
<tr class="memdesc:aeea51e1990497f38a468637f2e62ff72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calcola e restituisce la distanza tra il vertice this e il vertice in input.  <a href="#aeea51e1990497f38a468637f2e62ff72">Continua...</a><br /></td></tr>
<tr class="separator:aeea51e1990497f38a468637f2e62ff72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acee633c3e4a21a0638cc4c0d11300578"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#acee633c3e4a21a0638cc4c0d11300578">operator==</a> (const <a class="el" href="classDcel_1_1Vertex.html">Dcel::Vertex</a> &amp;otherVertex) const</td></tr>
<tr class="memdesc:acee633c3e4a21a0638cc4c0d11300578"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operatore di uguaglianza tra vertici.  <a href="#acee633c3e4a21a0638cc4c0d11300578">Continua...</a><br /></td></tr>
<tr class="separator:acee633c3e4a21a0638cc4c0d11300578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebded11891b2bdf5fd183598113a1aae"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#aebded11891b2bdf5fd183598113a1aae">operator!=</a> (const <a class="el" href="classDcel_1_1Vertex.html">Dcel::Vertex</a> &amp;othervertex) const</td></tr>
<tr class="memdesc:aebded11891b2bdf5fd183598113a1aae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operatore di disuguaglianza tra vertici.  <a href="#aebded11891b2bdf5fd183598113a1aae">Continua...</a><br /></td></tr>
<tr class="separator:aebded11891b2bdf5fd183598113a1aae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe6b523e517664a4f2c5d84d07c7539a"><td class="memItemLeft" align="right" valign="top"><a id="afe6b523e517664a4f2c5d84d07c7539a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#afe6b523e517664a4f2c5d84d07c7539a">setFlag</a> ()</td></tr>
<tr class="memdesc:afe6b523e517664a4f2c5d84d07c7539a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setta il flag del vertice a 1. <br /></td></tr>
<tr class="separator:afe6b523e517664a4f2c5d84d07c7539a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1478717bb5e45383acc6531c420dd57"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#aa1478717bb5e45383acc6531c420dd57">setFlag</a> (int newFlag)</td></tr>
<tr class="memdesc:aa1478717bb5e45383acc6531c420dd57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setta il flag del vertice.  <a href="#aa1478717bb5e45383acc6531c420dd57">Continua...</a><br /></td></tr>
<tr class="separator:aa1478717bb5e45383acc6531c420dd57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac289a84581b998d13634f2aafd977d5b"><td class="memItemLeft" align="right" valign="top"><a id="ac289a84581b998d13634f2aafd977d5b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#ac289a84581b998d13634f2aafd977d5b">resetFlag</a> ()</td></tr>
<tr class="memdesc:ac289a84581b998d13634f2aafd977d5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setta il flag della faccia a 0. <br /></td></tr>
<tr class="separator:ac289a84581b998d13634f2aafd977d5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b7e992ed35ffdfdc24b37f8d6fc2386"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#a7b7e992ed35ffdfdc24b37f8d6fc2386">setNormal</a> (const <a class="el" href="classPoint.html">Vec3</a> &amp;newNormal)</td></tr>
<tr class="memdesc:a7b7e992ed35ffdfdc24b37f8d6fc2386"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setta il vettore normale al vertice.  <a href="#a7b7e992ed35ffdfdc24b37f8d6fc2386">Continua...</a><br /></td></tr>
<tr class="separator:a7b7e992ed35ffdfdc24b37f8d6fc2386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9711522bca5e434f38a4dd693472017c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#a9711522bca5e434f38a4dd693472017c">setCoordinate</a> (const <a class="el" href="classPoint.html">Pointd</a> &amp;newCoordinate)</td></tr>
<tr class="memdesc:a9711522bca5e434f38a4dd693472017c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setta le coordinate del vertice.  <a href="#a9711522bca5e434f38a4dd693472017c">Continua...</a><br /></td></tr>
<tr class="separator:a9711522bca5e434f38a4dd693472017c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e6c739192c444e8965949e79041c1d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#a9e6c739192c444e8965949e79041c1d1">setCardinality</a> (int newCardinality)</td></tr>
<tr class="memdesc:a9e6c739192c444e8965949e79041c1d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setta la cardinalità del vertice.  <a href="#a9e6c739192c444e8965949e79041c1d1">Continua...</a><br /></td></tr>
<tr class="separator:a9e6c739192c444e8965949e79041c1d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc0756749e0c536697faf1ae826d133d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#adc0756749e0c536697faf1ae826d133d">decrementCardinality</a> ()</td></tr>
<tr class="memdesc:adc0756749e0c536697faf1ae826d133d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrementa la cardinalità del vertice (se essa è maggiore di 0)  <a href="#adc0756749e0c536697faf1ae826d133d">Continua...</a><br /></td></tr>
<tr class="separator:adc0756749e0c536697faf1ae826d133d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d8c450e431fd8babcdb7cfdf517b8fa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#a7d8c450e431fd8babcdb7cfdf517b8fa">incrementCardinality</a> ()</td></tr>
<tr class="memdesc:a7d8c450e431fd8babcdb7cfdf517b8fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Incrementa la cardinalità del vertice.  <a href="#a7d8c450e431fd8babcdb7cfdf517b8fa">Continua...</a><br /></td></tr>
<tr class="separator:a7d8c450e431fd8babcdb7cfdf517b8fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a949ee8a2fcace2c112238586f13daf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#a0a949ee8a2fcace2c112238586f13daf">getIncidentHalfEdge</a> ()</td></tr>
<tr class="memdesc:a0a949ee8a2fcace2c112238586f13daf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restituisce il puntatore all'half edge incidente sul vertice.  <a href="#a0a949ee8a2fcace2c112238586f13daf">Continua...</a><br /></td></tr>
<tr class="separator:a0a949ee8a2fcace2c112238586f13daf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c4e583a30166edb3cac283bb60b4191"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#a7c4e583a30166edb3cac283bb60b4191">setIncidentHalfEdge</a> (<a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *newIncidentHalfEdge)</td></tr>
<tr class="memdesc:a7c4e583a30166edb3cac283bb60b4191"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assegna un nuovo half edge incidente al vertice.  <a href="#a7c4e583a30166edb3cac283bb60b4191">Continua...</a><br /></td></tr>
<tr class="separator:a7c4e583a30166edb3cac283bb60b4191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31a432e6e0946b2a37dfa6d64ca318be"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#a31a432e6e0946b2a37dfa6d64ca318be">getNumberIncidentHalfEdges</a> () const</td></tr>
<tr class="memdesc:a31a432e6e0946b2a37dfa6d64ca318be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calcola e restituisce il numero di half edge (non di edge) incidenti sul vertice.  <a href="#a31a432e6e0946b2a37dfa6d64ca318be">Continua...</a><br /></td></tr>
<tr class="separator:a31a432e6e0946b2a37dfa6d64ca318be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6143f25470f9b18fdd82f393390bde7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#af6143f25470f9b18fdd82f393390bde7">getNumberIncidentFaces</a> () const</td></tr>
<tr class="memdesc:af6143f25470f9b18fdd82f393390bde7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calcola e restituisce il numero di facce incidenti sul vertice.  <a href="#af6143f25470f9b18fdd82f393390bde7">Continua...</a><br /></td></tr>
<tr class="separator:af6143f25470f9b18fdd82f393390bde7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac15392ca761019534eff4dde147bc6c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#aac15392ca761019534eff4dde147bc6c">getNumberAdjacentVertices</a> () const</td></tr>
<tr class="memdesc:aac15392ca761019534eff4dde147bc6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calcola e restituisce il numero di vertici adiacenti al vertice.  <a href="#aac15392ca761019534eff4dde147bc6c">Continua...</a><br /></td></tr>
<tr class="separator:aac15392ca761019534eff4dde147bc6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3481a1dbae85fac138e3b97f2a706814"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#a3481a1dbae85fac138e3b97f2a706814">findSharedHalfEdge</a> (const <a class="el" href="classDcel_1_1Vertex.html">Dcel::Vertex</a> *vertex) const</td></tr>
<tr class="memdesc:a3481a1dbae85fac138e3b97f2a706814"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione che cerca e restituisce l'half edge costante condiviso dal vertice this e vertex.  <a href="#a3481a1dbae85fac138e3b97f2a706814">Continua...</a><br /></td></tr>
<tr class="separator:a3481a1dbae85fac138e3b97f2a706814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa0923e4beb3ac2a23fc214fb1c414aa"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#afa0923e4beb3ac2a23fc214fb1c414aa">toString</a> () const</td></tr>
<tr class="memdesc:afa0923e4beb3ac2a23fc214fb1c414aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione toString di un vertice.  <a href="#afa0923e4beb3ac2a23fc214fb1c414aa">Continua...</a><br /></td></tr>
<tr class="separator:afa0923e4beb3ac2a23fc214fb1c414aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c14c465d70b06bc19e31cce812922b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Vertex_1_1ConstAdjacentVertexIterator.html">ConstAdjacentVertexIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#a1c14c465d70b06bc19e31cce812922b0">adjacentVertexBegin</a> () const</td></tr>
<tr class="memdesc:a1c14c465d70b06bc19e31cce812922b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1ConstAdjacentVertexIterator.html" title="Iteratore che permette di ciclare sui vertici adiacenti ad un vertice, garantendone l&#39;immutabilità...">Dcel::Vertex::ConstAdjacentVertexIterator</a>.  <a href="#a1c14c465d70b06bc19e31cce812922b0">Continua...</a><br /></td></tr>
<tr class="separator:a1c14c465d70b06bc19e31cce812922b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e1f914bf70f81de799cec2977fa7805"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Vertex_1_1ConstAdjacentVertexIterator.html">ConstAdjacentVertexIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#a1e1f914bf70f81de799cec2977fa7805">adjacentVertexEnd</a> () const</td></tr>
<tr class="memdesc:a1e1f914bf70f81de799cec2977fa7805"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di finalizzazione di <a class="el" href="classDcel_1_1Vertex_1_1ConstAdjacentVertexIterator.html" title="Iteratore che permette di ciclare sui vertici adiacenti ad un vertice, garantendone l&#39;immutabilità...">Dcel::Vertex::ConstAdjacentVertexIterator</a>.  <a href="#a1e1f914bf70f81de799cec2977fa7805">Continua...</a><br /></td></tr>
<tr class="separator:a1e1f914bf70f81de799cec2977fa7805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a906f8a6d916c8c8620f1e5c050e79171"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Vertex_1_1ConstAdjacentVertexIterator.html">ConstAdjacentVertexIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#a906f8a6d916c8c8620f1e5c050e79171">adjacentVertexBegin</a> (const <a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *start) const</td></tr>
<tr class="memdesc:a906f8a6d916c8c8620f1e5c050e79171"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1ConstAdjacentVertexIterator.html" title="Iteratore che permette di ciclare sui vertici adiacenti ad un vertice, garantendone l&#39;immutabilità...">Dcel::Vertex::ConstAdjacentVertexIterator</a>.  <a href="#a906f8a6d916c8c8620f1e5c050e79171">Continua...</a><br /></td></tr>
<tr class="separator:a906f8a6d916c8c8620f1e5c050e79171"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2fee372c3b87b206fa5b36e6f1b6733"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Vertex_1_1ConstAdjacentVertexIterator.html">ConstAdjacentVertexIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#aa2fee372c3b87b206fa5b36e6f1b6733">adjacentVertexBegin</a> (const <a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *start, const <a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *end) const</td></tr>
<tr class="memdesc:aa2fee372c3b87b206fa5b36e6f1b6733"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1ConstAdjacentVertexIterator.html" title="Iteratore che permette di ciclare sui vertici adiacenti ad un vertice, garantendone l&#39;immutabilità...">Dcel::Vertex::ConstAdjacentVertexIterator</a>.  <a href="#aa2fee372c3b87b206fa5b36e6f1b6733">Continua...</a><br /></td></tr>
<tr class="separator:aa2fee372c3b87b206fa5b36e6f1b6733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac321ceb04d62999b9208ba7996f990b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Vertex_1_1ConstAdjacentVertexIterator.html">ConstAdjacentVertexIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#ac321ceb04d62999b9208ba7996f990b7">adjacentVertexBegin</a> (const <a class="el" href="classDcel_1_1Vertex.html">Dcel::Vertex</a> *start) const</td></tr>
<tr class="memdesc:ac321ceb04d62999b9208ba7996f990b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1ConstAdjacentVertexIterator.html" title="Iteratore che permette di ciclare sui vertici adiacenti ad un vertice, garantendone l&#39;immutabilità...">Dcel::Vertex::ConstAdjacentVertexIterator</a>.  <a href="#ac321ceb04d62999b9208ba7996f990b7">Continua...</a><br /></td></tr>
<tr class="separator:ac321ceb04d62999b9208ba7996f990b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa49c28659041b8e7004b4d4d900aba01"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Vertex_1_1ConstAdjacentVertexIterator.html">ConstAdjacentVertexIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#aa49c28659041b8e7004b4d4d900aba01">adjacentVertexBegin</a> (const <a class="el" href="classDcel_1_1Vertex.html">Dcel::Vertex</a> *start, const <a class="el" href="classDcel_1_1Vertex.html">Dcel::Vertex</a> *end) const</td></tr>
<tr class="memdesc:aa49c28659041b8e7004b4d4d900aba01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1ConstAdjacentVertexIterator.html" title="Iteratore che permette di ciclare sui vertici adiacenti ad un vertice, garantendone l&#39;immutabilità...">Dcel::Vertex::ConstAdjacentVertexIterator</a>.  <a href="#aa49c28659041b8e7004b4d4d900aba01">Continua...</a><br /></td></tr>
<tr class="separator:aa49c28659041b8e7004b4d4d900aba01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89d29f126177950bf47fc6711f15977d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Vertex_1_1ConstOutgoingHalfEdgeIterator.html">ConstOutgoingHalfEdgeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#a89d29f126177950bf47fc6711f15977d">outgoingHalfEdgeBegin</a> () const</td></tr>
<tr class="memdesc:a89d29f126177950bf47fc6711f15977d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1ConstOutgoingHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge uscenti da un vertice, garantendone l&#39;immutabilità...">Dcel::Vertex::ConstOutgoingHalfEdgeIterator</a>.  <a href="#a89d29f126177950bf47fc6711f15977d">Continua...</a><br /></td></tr>
<tr class="separator:a89d29f126177950bf47fc6711f15977d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56446fd2de159875eed63b24eccda78e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Vertex_1_1ConstOutgoingHalfEdgeIterator.html">ConstOutgoingHalfEdgeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#a56446fd2de159875eed63b24eccda78e">outgoingHalfEdgeEnd</a> () const</td></tr>
<tr class="memdesc:a56446fd2de159875eed63b24eccda78e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di finalizzazione di <a class="el" href="classDcel_1_1Vertex_1_1ConstOutgoingHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge uscenti da un vertice, garantendone l&#39;immutabilità...">Dcel::Vertex::ConstOutgoingHalfEdgeIterator</a>.  <a href="#a56446fd2de159875eed63b24eccda78e">Continua...</a><br /></td></tr>
<tr class="separator:a56446fd2de159875eed63b24eccda78e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e306e44023dcc1de3e96ba13141a2af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Vertex_1_1ConstOutgoingHalfEdgeIterator.html">ConstOutgoingHalfEdgeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#a5e306e44023dcc1de3e96ba13141a2af">outgoingHalfEdgeBegin</a> (const <a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *start) const</td></tr>
<tr class="memdesc:a5e306e44023dcc1de3e96ba13141a2af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1ConstOutgoingHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge uscenti da un vertice, garantendone l&#39;immutabilità...">Dcel::Vertex::ConstOutgoingHalfEdgeIterator</a>.  <a href="#a5e306e44023dcc1de3e96ba13141a2af">Continua...</a><br /></td></tr>
<tr class="separator:a5e306e44023dcc1de3e96ba13141a2af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecd4db28ae400bd6eab79060a4a736a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Vertex_1_1ConstOutgoingHalfEdgeIterator.html">ConstOutgoingHalfEdgeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#aecd4db28ae400bd6eab79060a4a736a6">outgoingHalfEdgeBegin</a> (const <a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *start, const <a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *end) const</td></tr>
<tr class="memdesc:aecd4db28ae400bd6eab79060a4a736a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1ConstOutgoingHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge uscenti da un vertice, garantendone l&#39;immutabilità...">Dcel::Vertex::ConstOutgoingHalfEdgeIterator</a>.  <a href="#aecd4db28ae400bd6eab79060a4a736a6">Continua...</a><br /></td></tr>
<tr class="separator:aecd4db28ae400bd6eab79060a4a736a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b4bfb4d2931d387798ec245238b1cd9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Vertex_1_1ConstIncomingHalfEdgeIterator.html">ConstIncomingHalfEdgeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#a2b4bfb4d2931d387798ec245238b1cd9">incomingHalfEdgeBegin</a> () const</td></tr>
<tr class="memdesc:a2b4bfb4d2931d387798ec245238b1cd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1ConstIncomingHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge entranti in un vertice, garantendone l&#39;immutabilità...">Dcel::Vertex::ConstIncomingHalfEdgeIterator</a>.  <a href="#a2b4bfb4d2931d387798ec245238b1cd9">Continua...</a><br /></td></tr>
<tr class="separator:a2b4bfb4d2931d387798ec245238b1cd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a689e9e08818c7167bcbd34d92c73d6a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Vertex_1_1ConstIncomingHalfEdgeIterator.html">ConstIncomingHalfEdgeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#a689e9e08818c7167bcbd34d92c73d6a1">incomingHalfEdgeEnd</a> () const</td></tr>
<tr class="memdesc:a689e9e08818c7167bcbd34d92c73d6a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di finalizzazione di <a class="el" href="classDcel_1_1Vertex_1_1ConstIncomingHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge entranti in un vertice, garantendone l&#39;immutabilità...">Dcel::Vertex::ConstIncomingHalfEdgeIterator</a>.  <a href="#a689e9e08818c7167bcbd34d92c73d6a1">Continua...</a><br /></td></tr>
<tr class="separator:a689e9e08818c7167bcbd34d92c73d6a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98ca422a0e54443e40de401af868158f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Vertex_1_1ConstIncomingHalfEdgeIterator.html">ConstIncomingHalfEdgeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#a98ca422a0e54443e40de401af868158f">incomingHalfEdgeBegin</a> (const <a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *start) const</td></tr>
<tr class="memdesc:a98ca422a0e54443e40de401af868158f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1ConstIncomingHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge entranti in un vertice, garantendone l&#39;immutabilità...">Dcel::Vertex::ConstIncomingHalfEdgeIterator</a>.  <a href="#a98ca422a0e54443e40de401af868158f">Continua...</a><br /></td></tr>
<tr class="separator:a98ca422a0e54443e40de401af868158f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af15f36f08bc13ddbe09257fdd72c1d49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Vertex_1_1ConstIncomingHalfEdgeIterator.html">ConstIncomingHalfEdgeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#af15f36f08bc13ddbe09257fdd72c1d49">incomingHalfEdgeBegin</a> (const <a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *start, const <a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *end) const</td></tr>
<tr class="memdesc:af15f36f08bc13ddbe09257fdd72c1d49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1ConstIncomingHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge entranti in un vertice, garantendone l&#39;immutabilità...">Dcel::Vertex::ConstIncomingHalfEdgeIterator</a>.  <a href="#af15f36f08bc13ddbe09257fdd72c1d49">Continua...</a><br /></td></tr>
<tr class="separator:af15f36f08bc13ddbe09257fdd72c1d49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d259c52bf838c3ae79543cceea74a0d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Vertex_1_1ConstIncidentHalfEdgeIterator.html">ConstIncidentHalfEdgeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#a8d259c52bf838c3ae79543cceea74a0d">incidentHalfEdgeBegin</a> () const</td></tr>
<tr class="memdesc:a8d259c52bf838c3ae79543cceea74a0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1ConstIncidentHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge uscenti e entranti in un vertice. ">Dcel::Vertex::ConstIncidentHalfEdgeIterator</a>.  <a href="#a8d259c52bf838c3ae79543cceea74a0d">Continua...</a><br /></td></tr>
<tr class="separator:a8d259c52bf838c3ae79543cceea74a0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa79b7a35742590461fe3314df86aac8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Vertex_1_1ConstIncidentHalfEdgeIterator.html">ConstIncidentHalfEdgeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#aa79b7a35742590461fe3314df86aac8d">incidentHalfEdgeEnd</a> () const</td></tr>
<tr class="memdesc:aa79b7a35742590461fe3314df86aac8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di finalizzazione di <a class="el" href="classDcel_1_1Vertex_1_1ConstIncidentHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge uscenti e entranti in un vertice. ">Dcel::Vertex::ConstIncidentHalfEdgeIterator</a>.  <a href="#aa79b7a35742590461fe3314df86aac8d">Continua...</a><br /></td></tr>
<tr class="separator:aa79b7a35742590461fe3314df86aac8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a518c0c0b03a69bcd5594c19535dd9eb4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Vertex_1_1ConstIncidentHalfEdgeIterator.html">ConstIncidentHalfEdgeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#a518c0c0b03a69bcd5594c19535dd9eb4">incidentHalfEdgeBegin</a> (const <a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *start) const</td></tr>
<tr class="memdesc:a518c0c0b03a69bcd5594c19535dd9eb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1ConstIncidentHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge uscenti e entranti in un vertice. ">Dcel::Vertex::ConstIncidentHalfEdgeIterator</a>.  <a href="#a518c0c0b03a69bcd5594c19535dd9eb4">Continua...</a><br /></td></tr>
<tr class="separator:a518c0c0b03a69bcd5594c19535dd9eb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a082b59791d3c94fc7554c9af92513298"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Vertex_1_1ConstIncidentHalfEdgeIterator.html">ConstIncidentHalfEdgeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#a082b59791d3c94fc7554c9af92513298">incidentHalfEdgeBegin</a> (const <a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *start, const <a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *end) const</td></tr>
<tr class="memdesc:a082b59791d3c94fc7554c9af92513298"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1ConstIncidentHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge uscenti e entranti in un vertice. ">Dcel::Vertex::ConstIncidentHalfEdgeIterator</a>.  <a href="#a082b59791d3c94fc7554c9af92513298">Continua...</a><br /></td></tr>
<tr class="separator:a082b59791d3c94fc7554c9af92513298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46aafc7a3284fff47fe9c53e295bf7d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Vertex_1_1ConstIncidentFaceIterator.html">ConstIncidentFaceIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#a46aafc7a3284fff47fe9c53e295bf7d2">incidentFaceBegin</a> () const</td></tr>
<tr class="memdesc:a46aafc7a3284fff47fe9c53e295bf7d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1ConstIncidentFaceIterator.html" title="Iteratore che permette di ciclare sulle facce incidenti su un vertice. ">Dcel::Vertex::ConstIncidentFaceIterator</a>.  <a href="#a46aafc7a3284fff47fe9c53e295bf7d2">Continua...</a><br /></td></tr>
<tr class="separator:a46aafc7a3284fff47fe9c53e295bf7d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc514003dac6cc6237648d5951d78b0c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Vertex_1_1ConstIncidentFaceIterator.html">ConstIncidentFaceIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#abc514003dac6cc6237648d5951d78b0c">incidentFaceEnd</a> () const</td></tr>
<tr class="memdesc:abc514003dac6cc6237648d5951d78b0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di finalizzazione di <a class="el" href="classDcel_1_1Vertex_1_1ConstIncidentFaceIterator.html" title="Iteratore che permette di ciclare sulle facce incidenti su un vertice. ">Dcel::Vertex::ConstIncidentFaceIterator</a>.  <a href="#abc514003dac6cc6237648d5951d78b0c">Continua...</a><br /></td></tr>
<tr class="separator:abc514003dac6cc6237648d5951d78b0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30b9541b9d8e703f286b186a261ba187"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Vertex_1_1ConstIncidentFaceIterator.html">ConstIncidentFaceIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#a30b9541b9d8e703f286b186a261ba187">incidentFaceBegin</a> (const <a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *start) const</td></tr>
<tr class="memdesc:a30b9541b9d8e703f286b186a261ba187"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1ConstIncidentFaceIterator.html" title="Iteratore che permette di ciclare sulle facce incidenti su un vertice. ">Dcel::Vertex::ConstIncidentFaceIterator</a>.  <a href="#a30b9541b9d8e703f286b186a261ba187">Continua...</a><br /></td></tr>
<tr class="separator:a30b9541b9d8e703f286b186a261ba187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad736f5ba65d134dc7781e7bbfdf3776b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Vertex_1_1ConstIncidentFaceIterator.html">ConstIncidentFaceIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#ad736f5ba65d134dc7781e7bbfdf3776b">incidentFaceBegin</a> (const <a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *start, const <a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *end) const</td></tr>
<tr class="memdesc:ad736f5ba65d134dc7781e7bbfdf3776b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1ConstIncidentFaceIterator.html" title="Iteratore che permette di ciclare sulle facce incidenti su un vertice. ">Dcel::Vertex::ConstIncidentFaceIterator</a>.  <a href="#ad736f5ba65d134dc7781e7bbfdf3776b">Continua...</a><br /></td></tr>
<tr class="separator:ad736f5ba65d134dc7781e7bbfdf3776b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa15a987ee31b7012ed0d1cb51f68d66f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#aa15a987ee31b7012ed0d1cb51f68d66f">updateNormal</a> ()</td></tr>
<tr class="memdesc:aa15a987ee31b7012ed0d1cb51f68d66f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ricalcola e restituisce la normale al vertice, e aggiorna la cardinalità del vertice.  <a href="#aa15a987ee31b7012ed0d1cb51f68d66f">Continua...</a><br /></td></tr>
<tr class="separator:aa15a987ee31b7012ed0d1cb51f68d66f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6909cf4a951dc2504caaeaae872fde1"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#af6909cf4a951dc2504caaeaae872fde1">updateCardinality</a> ()</td></tr>
<tr class="memdesc:af6909cf4a951dc2504caaeaae872fde1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ricalcola e restituisce la cardinalità del vertice, ossia il numero di <b>edge</b> (non half edge!) incidenti.  <a href="#af6909cf4a951dc2504caaeaae872fde1">Continua...</a><br /></td></tr>
<tr class="separator:af6909cf4a951dc2504caaeaae872fde1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f3c7f3495daa71a2a2b72ecde413210"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#a8f3c7f3495daa71a2a2b72ecde413210">findSharedHalfEdge</a> (const <a class="el" href="classDcel_1_1Vertex.html">Dcel::Vertex</a> *vertex)</td></tr>
<tr class="memdesc:a8f3c7f3495daa71a2a2b72ecde413210"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione che cerca e restituisce l'half edge condiviso dal vertice this e vertex.  <a href="#a8f3c7f3495daa71a2a2b72ecde413210">Continua...</a><br /></td></tr>
<tr class="separator:a8f3c7f3495daa71a2a2b72ecde413210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af625660c1b4ab1efee5c4c494a1d5596"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Vertex_1_1AdjacentVertexIterator.html">AdjacentVertexIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#af625660c1b4ab1efee5c4c494a1d5596">adjacentVertexBegin</a> ()</td></tr>
<tr class="memdesc:af625660c1b4ab1efee5c4c494a1d5596"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1AdjacentVertexIterator.html" title="Iteratore che permette di ciclare sui vertici adiacenti ad un vertice. ">Dcel::Vertex::AdjacentVertexIterator</a>.  <a href="#af625660c1b4ab1efee5c4c494a1d5596">Continua...</a><br /></td></tr>
<tr class="separator:af625660c1b4ab1efee5c4c494a1d5596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a028641a4f49729dd099c62b364a6c1cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Vertex_1_1AdjacentVertexIterator.html">AdjacentVertexIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#a028641a4f49729dd099c62b364a6c1cf">adjacentVertexEnd</a> ()</td></tr>
<tr class="memdesc:a028641a4f49729dd099c62b364a6c1cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di finalizzazione di <a class="el" href="classDcel_1_1Vertex_1_1AdjacentVertexIterator.html" title="Iteratore che permette di ciclare sui vertici adiacenti ad un vertice. ">Dcel::Vertex::AdjacentVertexIterator</a>.  <a href="#a028641a4f49729dd099c62b364a6c1cf">Continua...</a><br /></td></tr>
<tr class="separator:a028641a4f49729dd099c62b364a6c1cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38680e4442bd79d786cc7b697cff8600"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Vertex_1_1AdjacentVertexIterator.html">AdjacentVertexIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#a38680e4442bd79d786cc7b697cff8600">adjacentVertexBegin</a> (<a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *start)</td></tr>
<tr class="memdesc:a38680e4442bd79d786cc7b697cff8600"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1AdjacentVertexIterator.html" title="Iteratore che permette di ciclare sui vertici adiacenti ad un vertice. ">Dcel::Vertex::AdjacentVertexIterator</a>.  <a href="#a38680e4442bd79d786cc7b697cff8600">Continua...</a><br /></td></tr>
<tr class="separator:a38680e4442bd79d786cc7b697cff8600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad89cb5c8e39ac53d35b3c3d46c904667"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Vertex_1_1AdjacentVertexIterator.html">AdjacentVertexIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#ad89cb5c8e39ac53d35b3c3d46c904667">adjacentVertexBegin</a> (<a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *start, <a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *end)</td></tr>
<tr class="memdesc:ad89cb5c8e39ac53d35b3c3d46c904667"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1AdjacentVertexIterator.html" title="Iteratore che permette di ciclare sui vertici adiacenti ad un vertice. ">Dcel::Vertex::AdjacentVertexIterator</a>.  <a href="#ad89cb5c8e39ac53d35b3c3d46c904667">Continua...</a><br /></td></tr>
<tr class="separator:ad89cb5c8e39ac53d35b3c3d46c904667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa0dc803d6d1ebd22a0e50c345e2da5c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Vertex_1_1AdjacentVertexIterator.html">AdjacentVertexIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#afa0dc803d6d1ebd22a0e50c345e2da5c">adjacentVertexBegin</a> (<a class="el" href="classDcel_1_1Vertex.html">Dcel::Vertex</a> *start)</td></tr>
<tr class="memdesc:afa0dc803d6d1ebd22a0e50c345e2da5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1AdjacentVertexIterator.html" title="Iteratore che permette di ciclare sui vertici adiacenti ad un vertice. ">Dcel::Vertex::AdjacentVertexIterator</a>.  <a href="#afa0dc803d6d1ebd22a0e50c345e2da5c">Continua...</a><br /></td></tr>
<tr class="separator:afa0dc803d6d1ebd22a0e50c345e2da5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5748eefe944c0bde7e36c719c5721781"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Vertex_1_1AdjacentVertexIterator.html">AdjacentVertexIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#a5748eefe944c0bde7e36c719c5721781">adjacentVertexBegin</a> (<a class="el" href="classDcel_1_1Vertex.html">Dcel::Vertex</a> *start, <a class="el" href="classDcel_1_1Vertex.html">Dcel::Vertex</a> *end)</td></tr>
<tr class="memdesc:a5748eefe944c0bde7e36c719c5721781"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1AdjacentVertexIterator.html" title="Iteratore che permette di ciclare sui vertici adiacenti ad un vertice. ">Dcel::Vertex::AdjacentVertexIterator</a>.  <a href="#a5748eefe944c0bde7e36c719c5721781">Continua...</a><br /></td></tr>
<tr class="separator:a5748eefe944c0bde7e36c719c5721781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51ad4d92f2a1dabea8dba215858794b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Vertex_1_1OutgoingHalfEdgeIterator.html">OutgoingHalfEdgeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#a51ad4d92f2a1dabea8dba215858794b5">outgoingHalfEdgeBegin</a> ()</td></tr>
<tr class="memdesc:a51ad4d92f2a1dabea8dba215858794b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1OutgoingHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge uscenti da un vertice. ">Dcel::Vertex::OutgoingHalfEdgeIterator</a>.  <a href="#a51ad4d92f2a1dabea8dba215858794b5">Continua...</a><br /></td></tr>
<tr class="separator:a51ad4d92f2a1dabea8dba215858794b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4d3e433d920cf11566efdd50d3043fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Vertex_1_1OutgoingHalfEdgeIterator.html">OutgoingHalfEdgeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#ad4d3e433d920cf11566efdd50d3043fa">outgoingHalfEdgeEnd</a> ()</td></tr>
<tr class="memdesc:ad4d3e433d920cf11566efdd50d3043fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di finalizzazione di <a class="el" href="classDcel_1_1Vertex_1_1OutgoingHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge uscenti da un vertice. ">Dcel::Vertex::OutgoingHalfEdgeIterator</a>.  <a href="#ad4d3e433d920cf11566efdd50d3043fa">Continua...</a><br /></td></tr>
<tr class="separator:ad4d3e433d920cf11566efdd50d3043fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa818fa51cc350dd63e3b16666339632d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Vertex_1_1OutgoingHalfEdgeIterator.html">OutgoingHalfEdgeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#aa818fa51cc350dd63e3b16666339632d">outgoingHalfEdgeBegin</a> (<a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *start)</td></tr>
<tr class="memdesc:aa818fa51cc350dd63e3b16666339632d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1OutgoingHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge uscenti da un vertice. ">Dcel::Vertex::OutgoingHalfEdgeIterator</a>.  <a href="#aa818fa51cc350dd63e3b16666339632d">Continua...</a><br /></td></tr>
<tr class="separator:aa818fa51cc350dd63e3b16666339632d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a521ec35b8c0bf0fc04ccda8daaf0b1ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Vertex_1_1OutgoingHalfEdgeIterator.html">OutgoingHalfEdgeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#a521ec35b8c0bf0fc04ccda8daaf0b1ec">outgoingHalfEdgeBegin</a> (<a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *start, <a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *end)</td></tr>
<tr class="memdesc:a521ec35b8c0bf0fc04ccda8daaf0b1ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1OutgoingHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge uscenti da un vertice. ">Dcel::Vertex::OutgoingHalfEdgeIterator</a>.  <a href="#a521ec35b8c0bf0fc04ccda8daaf0b1ec">Continua...</a><br /></td></tr>
<tr class="separator:a521ec35b8c0bf0fc04ccda8daaf0b1ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2520372b90e7700f1c3ad5efcf86485c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Vertex_1_1IncomingHalfEdgeIterator.html">IncomingHalfEdgeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#a2520372b90e7700f1c3ad5efcf86485c">incomingHalfEdgeBegin</a> ()</td></tr>
<tr class="memdesc:a2520372b90e7700f1c3ad5efcf86485c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1IncomingHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge entranti in un vertice. ">Dcel::Vertex::IncomingHalfEdgeIterator</a>.  <a href="#a2520372b90e7700f1c3ad5efcf86485c">Continua...</a><br /></td></tr>
<tr class="separator:a2520372b90e7700f1c3ad5efcf86485c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeacd416c59aef198db8fa8507fa43b11"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Vertex_1_1IncomingHalfEdgeIterator.html">IncomingHalfEdgeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#aeacd416c59aef198db8fa8507fa43b11">incomingHalfEdgeEnd</a> ()</td></tr>
<tr class="memdesc:aeacd416c59aef198db8fa8507fa43b11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di finalizzazione di <a class="el" href="classDcel_1_1Vertex_1_1IncomingHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge entranti in un vertice. ">Dcel::Vertex::IncomingHalfEdgeIterator</a>.  <a href="#aeacd416c59aef198db8fa8507fa43b11">Continua...</a><br /></td></tr>
<tr class="separator:aeacd416c59aef198db8fa8507fa43b11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcb79cd6f3e85146eac1ecd7bae72cf0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Vertex_1_1IncomingHalfEdgeIterator.html">IncomingHalfEdgeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#afcb79cd6f3e85146eac1ecd7bae72cf0">incomingHalfEdgeBegin</a> (<a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *start)</td></tr>
<tr class="memdesc:afcb79cd6f3e85146eac1ecd7bae72cf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1IncomingHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge entranti in un vertice. ">Dcel::Vertex::IncomingHalfEdgeIterator</a>.  <a href="#afcb79cd6f3e85146eac1ecd7bae72cf0">Continua...</a><br /></td></tr>
<tr class="separator:afcb79cd6f3e85146eac1ecd7bae72cf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a572ed133e758f8c9c7744b9a4947b037"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Vertex_1_1IncomingHalfEdgeIterator.html">IncomingHalfEdgeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#a572ed133e758f8c9c7744b9a4947b037">incomingHalfEdgeBegin</a> (<a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *start, <a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *end)</td></tr>
<tr class="memdesc:a572ed133e758f8c9c7744b9a4947b037"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1IncomingHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge entranti in un vertice. ">Dcel::Vertex::IncomingHalfEdgeIterator</a>.  <a href="#a572ed133e758f8c9c7744b9a4947b037">Continua...</a><br /></td></tr>
<tr class="separator:a572ed133e758f8c9c7744b9a4947b037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90f1a9cf6aefb84daca8768c74471c72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Vertex_1_1IncidentHalfEdgeIterator.html">IncidentHalfEdgeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#a90f1a9cf6aefb84daca8768c74471c72">incidentHalfEdgeBegin</a> ()</td></tr>
<tr class="memdesc:a90f1a9cf6aefb84daca8768c74471c72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1IncidentHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge uscenti e entranti in un vertice. ">Dcel::Vertex::IncidentHalfEdgeIterator</a>.  <a href="#a90f1a9cf6aefb84daca8768c74471c72">Continua...</a><br /></td></tr>
<tr class="separator:a90f1a9cf6aefb84daca8768c74471c72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68a94f4290722b3b5e635170a42976a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Vertex_1_1IncidentHalfEdgeIterator.html">IncidentHalfEdgeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#a68a94f4290722b3b5e635170a42976a5">incidentHalfEdgeEnd</a> ()</td></tr>
<tr class="memdesc:a68a94f4290722b3b5e635170a42976a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di finalizzazione di <a class="el" href="classDcel_1_1Vertex_1_1IncidentHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge uscenti e entranti in un vertice. ">Dcel::Vertex::IncidentHalfEdgeIterator</a>.  <a href="#a68a94f4290722b3b5e635170a42976a5">Continua...</a><br /></td></tr>
<tr class="separator:a68a94f4290722b3b5e635170a42976a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8f34fdd1b9fbc78f27cfcc7b8d91e11"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Vertex_1_1IncidentHalfEdgeIterator.html">IncidentHalfEdgeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#ac8f34fdd1b9fbc78f27cfcc7b8d91e11">incidentHalfEdgeBegin</a> (<a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *start)</td></tr>
<tr class="memdesc:ac8f34fdd1b9fbc78f27cfcc7b8d91e11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1IncidentHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge uscenti e entranti in un vertice. ">Dcel::Vertex::IncidentHalfEdgeIterator</a>.  <a href="#ac8f34fdd1b9fbc78f27cfcc7b8d91e11">Continua...</a><br /></td></tr>
<tr class="separator:ac8f34fdd1b9fbc78f27cfcc7b8d91e11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7ca1be7938dec64f0008eef461622bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Vertex_1_1IncidentHalfEdgeIterator.html">IncidentHalfEdgeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#af7ca1be7938dec64f0008eef461622bb">incidentHalfEdgeBegin</a> (<a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *start, <a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *end)</td></tr>
<tr class="memdesc:af7ca1be7938dec64f0008eef461622bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1IncidentHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge uscenti e entranti in un vertice. ">Dcel::Vertex::IncidentHalfEdgeIterator</a>.  <a href="#af7ca1be7938dec64f0008eef461622bb">Continua...</a><br /></td></tr>
<tr class="separator:af7ca1be7938dec64f0008eef461622bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae15c9bc16b4d82ec9fbac027b43f3f15"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Vertex_1_1IncidentFaceIterator.html">IncidentFaceIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#ae15c9bc16b4d82ec9fbac027b43f3f15">incidentFaceBegin</a> ()</td></tr>
<tr class="memdesc:ae15c9bc16b4d82ec9fbac027b43f3f15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1IncidentFaceIterator.html" title="Iteratore che permette di ciclare sulle facce incidenti su un vertice. ">Dcel::Vertex::IncidentFaceIterator</a>.  <a href="#ae15c9bc16b4d82ec9fbac027b43f3f15">Continua...</a><br /></td></tr>
<tr class="separator:ae15c9bc16b4d82ec9fbac027b43f3f15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c7884f95c62825149bc2c8a09844219"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Vertex_1_1IncidentFaceIterator.html">IncidentFaceIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#a6c7884f95c62825149bc2c8a09844219">incidentFaceEnd</a> ()</td></tr>
<tr class="memdesc:a6c7884f95c62825149bc2c8a09844219"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di finalizzazione di <a class="el" href="classDcel_1_1Vertex_1_1IncidentFaceIterator.html" title="Iteratore che permette di ciclare sulle facce incidenti su un vertice. ">Dcel::Vertex::IncidentFaceIterator</a>.  <a href="#a6c7884f95c62825149bc2c8a09844219">Continua...</a><br /></td></tr>
<tr class="separator:a6c7884f95c62825149bc2c8a09844219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37dd8578f18308f9d111919935596727"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Vertex_1_1IncidentFaceIterator.html">IncidentFaceIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#a37dd8578f18308f9d111919935596727">incidentFaceBegin</a> (<a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *start)</td></tr>
<tr class="memdesc:a37dd8578f18308f9d111919935596727"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1IncidentFaceIterator.html" title="Iteratore che permette di ciclare sulle facce incidenti su un vertice. ">Dcel::Vertex::IncidentFaceIterator</a>.  <a href="#a37dd8578f18308f9d111919935596727">Continua...</a><br /></td></tr>
<tr class="separator:a37dd8578f18308f9d111919935596727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1699e2df8c65baf04b7ed3fbc7293d14"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDcel_1_1Vertex_1_1IncidentFaceIterator.html">IncidentFaceIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#a1699e2df8c65baf04b7ed3fbc7293d14">incidentFaceBegin</a> (<a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *start, <a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *end)</td></tr>
<tr class="memdesc:a1699e2df8c65baf04b7ed3fbc7293d14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1IncidentFaceIterator.html" title="Iteratore che permette di ciclare sulle facce incidenti su un vertice. ">Dcel::Vertex::IncidentFaceIterator</a>.  <a href="#a1699e2df8c65baf04b7ed3fbc7293d14">Continua...</a><br /></td></tr>
<tr class="separator:a1699e2df8c65baf04b7ed3fbc7293d14"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Membri protetti</h2></td></tr>
<tr class="memitem:ab472df61b8c1c5671cea2367d837cdc6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#ab472df61b8c1c5671cea2367d837cdc6">setId</a> (unsigned int <a class="el" href="classDcel_1_1Vertex.html#ac7bc1e3501db91019ccf165639e8f243">id</a>)</td></tr>
<tr class="memdesc:ab472df61b8c1c5671cea2367d837cdc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setta l'id del vertice.  <a href="#ab472df61b8c1c5671cea2367d837cdc6">Continua...</a><br /></td></tr>
<tr class="separator:ab472df61b8c1c5671cea2367d837cdc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Attributi protetti</h2></td></tr>
<tr class="memitem:a6a1d4109ed7c63f1c6d2053443e79125"><td class="memItemLeft" align="right" valign="top"><a id="a6a1d4109ed7c63f1c6d2053443e79125"></a>
<a class="el" href="classPoint.html">Pointd</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#a6a1d4109ed7c63f1c6d2053443e79125">coordinate</a></td></tr>
<tr class="memdesc:a6a1d4109ed7c63f1c6d2053443e79125"><td class="mdescLeft">&#160;</td><td class="mdescRight">Punto nello spazio 3D rappresentante la posizione del vertice. <br /></td></tr>
<tr class="separator:a6a1d4109ed7c63f1c6d2053443e79125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d86451c230608f56136e98917f22140"><td class="memItemLeft" align="right" valign="top"><a id="a5d86451c230608f56136e98917f22140"></a>
<a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#a5d86451c230608f56136e98917f22140">incidentHalfEdge</a></td></tr>
<tr class="memdesc:a5d86451c230608f56136e98917f22140"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uno degli half edge uscenti incidenti sul vertice. <br /></td></tr>
<tr class="separator:a5d86451c230608f56136e98917f22140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30e6c8f4a2c38095f8b019185d798fb9"><td class="memItemLeft" align="right" valign="top"><a id="a30e6c8f4a2c38095f8b019185d798fb9"></a>
<a class="el" href="classPoint.html">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#a30e6c8f4a2c38095f8b019185d798fb9">normal</a></td></tr>
<tr class="memdesc:a30e6c8f4a2c38095f8b019185d798fb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vettore normale al vertice. <br /></td></tr>
<tr class="separator:a30e6c8f4a2c38095f8b019185d798fb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a532c8cd4a47dc77aa49142d74024a964"><td class="memItemLeft" align="right" valign="top"><a id="a532c8cd4a47dc77aa49142d74024a964"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#a532c8cd4a47dc77aa49142d74024a964">cardinality</a></td></tr>
<tr class="memdesc:a532c8cd4a47dc77aa49142d74024a964"><td class="mdescLeft">&#160;</td><td class="mdescRight">Numero di edge (metà degli half edge) incidenti sul vertice. <br /></td></tr>
<tr class="separator:a532c8cd4a47dc77aa49142d74024a964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7bc1e3501db91019ccf165639e8f243"><td class="memItemLeft" align="right" valign="top"><a id="ac7bc1e3501db91019ccf165639e8f243"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#ac7bc1e3501db91019ccf165639e8f243">id</a></td></tr>
<tr class="memdesc:ac7bc1e3501db91019ccf165639e8f243"><td class="mdescLeft">&#160;</td><td class="mdescRight">Id univoco, all'interno della <a class="el" href="classDcel.html" title="Struttura dati Double Conntected Edge List. ">Dcel</a>, associato al vertice. <br /></td></tr>
<tr class="separator:ac7bc1e3501db91019ccf165639e8f243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae29ca6ca3f89c5a48f5f52f86841ab31"><td class="memItemLeft" align="right" valign="top"><a id="ae29ca6ca3f89c5a48f5f52f86841ab31"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDcel_1_1Vertex.html#ae29ca6ca3f89c5a48f5f52f86841ab31">flag</a></td></tr>
<tr class="memdesc:ae29ca6ca3f89c5a48f5f52f86841ab31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag personalizzabile, associato al vertice. <br /></td></tr>
<tr class="separator:ae29ca6ca3f89c5a48f5f52f86841ab31"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friend</h2></td></tr>
<tr class="memitem:aa1fcaa71081ba7020ce73fec523e4d9b"><td class="memItemLeft" align="right" valign="top"><a id="aa1fcaa71081ba7020ce73fec523e4d9b"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>Dcel</b></td></tr>
<tr class="separator:aa1fcaa71081ba7020ce73fec523e4d9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Descrizione dettagliata</h2>
<div class="textblock"><p>Classe rappresentante un vertice della DCEL. </p>
<p>All'interno della <a class="el" href="classDcel.html" title="Struttura dati Double Conntected Edge List. ">Dcel</a>, le sue componenti fondamentali sono:</p><ul>
<li>coordinate: Pointd contenente la posizione in uno spazio 3D del vertice; <br />
</li>
<li>incicentHalfEdge: uno degli half edge <b>uscenti</b> incidenti al vertice, ossia half edge che ha come from vertex il vertice stesso. <br />
</li>
</ul>
<p>Per una corretta gestione della <a class="el" href="classDcel.html" title="Struttura dati Double Conntected Edge List. ">Dcel</a>, ogni <a class="el" href="classDcel_1_1Vertex.html" title="Classe rappresentante un vertice della DCEL. ">Dcel::Vertex</a> <code>v</code> deve avere un <code>incidentHalfEdge</code>. Tale halfEdge deve avere come fromVertex il vertice <code>v</code>, e il suo twin deve avere <code>v</code> come toVertex. Devono poi essere rispettate le regole degli halfEdge e dei loro vertici incidenti sulle relazioni di prev e next.</p>
<p>Le altre componenti che compongono il vertice sono:</p><ul>
<li>normal: vettore 3D rappresentante la normale del vertice, che solitamente è la media delle normali delle facce incidenti;<br />
</li>
<li>cardinality: numero di edge (ossia la metà del numero di half edge) incidenti sul vertice;<br />
</li>
<li>id: intero senza segno univoco all'interno della lista dei vertici della <a class="el" href="classDcel.html" title="Struttura dati Double Conntected Edge List. ">Dcel</a>, non modificabile dall'utente. Può essere usato per identificare il vertice all'interno della <a class="el" href="classDcel.html" title="Struttura dati Double Conntected Edge List. ">Dcel</a> (in modo meno efficiente rispetto all'utilizzo di un puntatore);<br />
</li>
<li>flag: intero personalizzabile dall'utente. <br />
</li>
</ul>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000011">Da fare:</a></b></dt><dd>color: colore associato al vertice;<br />
</dd></dl>
<dl class="section author"><dt>Autore</dt><dd>Alessandro Muntoni (<a href="#" onclick="location.href='mai'+'lto:'+'mun'+'to'+'ni.'+'al'+'ess'+'an'+'dro'+'@g'+'mai'+'l.'+'com'; return false;">munto<span style="display: none;">.nosp@m.</span>ni.a<span style="display: none;">.nosp@m.</span>lessa<span style="display: none;">.nosp@m.</span>ndro<span style="display: none;">.nosp@m.</span>@gmai<span style="display: none;">.nosp@m.</span>l.co<span style="display: none;">.nosp@m.</span>m</a>) </dd></dl>
</div><h2 class="groupheader">Documentazione dei costruttori e dei distruttori</h2>
<a id="a2da229e7ef9443810ec4f61da9a33e76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2da229e7ef9443810ec4f61da9a33e76">&sect;&nbsp;</a></span>Vertex() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Dcel::Vertex::Vertex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Costruttore di default. </p>
<p>Crea un vertice con:</p><ul>
<li>posizione pari a (0, 0, 0);</li>
<li>half edge incidente settato a nullptr;</li>
<li>vettore normale pari a (0, 0, 0);</li>
<li>cardinalità pari a 0;</li>
<li>id pari a 0;</li>
<li>flag pari a 0. </li>
</ul>

</div>
</div>
<a id="ad3da5e567cfaf3d1d4c9a3dfecf13564"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3da5e567cfaf3d1d4c9a3dfecf13564">&sect;&nbsp;</a></span>Vertex() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Dcel::Vertex::Vertex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Pointd</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Costruttore di default. </p>
<p>Crea un vertice con:</p><ul>
<li>posizione pari al parametro in input p;</li>
<li>half edge incidente settato a nullptr;</li>
<li>vettore normale pari a (0, 0, 0);</li>
<li>cardinalità pari a 0;</li>
<li>id pari a 0;</li>
<li>flag pari a 0.</li>
</ul>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>Poind rappresentante la posizione assegnata al vertice </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a31aaedc4b3477ed85390daa341f3976e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31aaedc4b3477ed85390daa341f3976e">&sect;&nbsp;</a></span>Vertex() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Dcel::Vertex::Vertex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Pointd</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *&#160;</td>
          <td class="paramname"><em>halfEdge</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Costruttore di default. </p>
<p>Crea un vertice con:</p><ul>
<li>posizione pari al parametro in input p;</li>
<li>half edge incidente pari al parametro in input halfEdge;</li>
<li>vettore normale pari a (0, 0, 0);</li>
<li>cardinalità pari a 0;</li>
<li>id pari a 0;</li>
<li>flag pari a 0.</li>
</ul>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>Poind rappresentante la posizione assegnata al vertice </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">halfEdge</td><td>puntatore all'half edge incidente assegnato al vertice </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a58eb006d5da7901f5cbc5f103e919a0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58eb006d5da7901f5cbc5f103e919a0f">&sect;&nbsp;</a></span>Vertex() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Dcel::Vertex::Vertex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Pointd</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *&#160;</td>
          <td class="paramname"><em>halfEdge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cardinality</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Costruttore di default. </p>
<p>Crea un vertice con:</p><ul>
<li>posizione pari al parametro in input p;</li>
<li>half edge incidente pari al parametro in input halfEdge;</li>
<li>vettore normale pari a (0, 0, 0);</li>
<li>cardinalità pari al parametro in input cardinality;</li>
<li>id pari a 0;</li>
<li>flag pari a 0.</li>
</ul>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>Poind rappresentante la posizione assegnata al vertice </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">halfEdge</td><td>puntatore all'half edge incidente assegnato al vertice </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cardinality</td><td>cardinalità settata al vertice </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3f736bd9320adb06315ba1c7a12f1f87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f736bd9320adb06315ba1c7a12f1f87">&sect;&nbsp;</a></span>~Vertex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Dcel::Vertex::~Vertex </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Distruttore vuoto. </p>
<p>La classe <a class="el" href="classDcel.html" title="Struttura dati Double Conntected Edge List. ">Dcel</a> dovrà occuparsi di eliminare tutti i riferimenti in essa contenuti (e quindi contenuti di conseguenza anche nella classe <a class="el" href="classDcel_1_1Vertex.html" title="Classe rappresentante un vertice della DCEL. ">Dcel::Vertex</a>). </p>

</div>
</div>
<h2 class="groupheader">Documentazione delle funzioni membro</h2>
<a id="a1c14c465d70b06bc19e31cce812922b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c14c465d70b06bc19e31cce812922b0">&sect;&nbsp;</a></span>adjacentVertexBegin() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Vertex_1_1ConstAdjacentVertexIterator.html">Dcel::Vertex::ConstAdjacentVertexIterator</a> Dcel::Vertex::adjacentVertexBegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1ConstAdjacentVertexIterator.html" title="Iteratore che permette di ciclare sui vertici adiacenti ad un vertice, garantendone l&#39;immutabilità...">Dcel::Vertex::ConstAdjacentVertexIterator</a>. </p>
<p>Permette di ciclare sui vertici adiacenti al vertice, partendo dal toVertex dell'incidentHalfEdge.</p>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore che punta al toVertex dell'incidentHalfEdge </dd></dl>

</div>
</div>
<a id="a906f8a6d916c8c8620f1e5c050e79171"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a906f8a6d916c8c8620f1e5c050e79171">&sect;&nbsp;</a></span>adjacentVertexBegin() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Vertex_1_1ConstAdjacentVertexIterator.html">Dcel::Vertex::ConstAdjacentVertexIterator</a> Dcel::Vertex::adjacentVertexBegin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *&#160;</td>
          <td class="paramname"><em>start</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1ConstAdjacentVertexIterator.html" title="Iteratore che permette di ciclare sui vertici adiacenti ad un vertice, garantendone l&#39;immutabilità...">Dcel::Vertex::ConstAdjacentVertexIterator</a>. </p>
<p>Permette di ciclare sui vertici adiacenti al vertice, partendo dal toVertex dell'half edge start.</p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>half edge di partenza </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Avvertimento</dt><dd>Se start non risulta avere il vertice this come fromoVertex, viene lanciata un'asserzione e il programma termina </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore che punta al toVertex dell'half edge start </dd></dl>

</div>
</div>
<a id="aa2fee372c3b87b206fa5b36e6f1b6733"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2fee372c3b87b206fa5b36e6f1b6733">&sect;&nbsp;</a></span>adjacentVertexBegin() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Vertex_1_1ConstAdjacentVertexIterator.html">Dcel::Vertex::ConstAdjacentVertexIterator</a> Dcel::Vertex::adjacentVertexBegin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1ConstAdjacentVertexIterator.html" title="Iteratore che permette di ciclare sui vertici adiacenti ad un vertice, garantendone l&#39;immutabilità...">Dcel::Vertex::ConstAdjacentVertexIterator</a>. </p>
<p>Permette di ciclare sui vertici adiacenti al vertice, partendo dal toVertex dell'half edge start e fino al toVertex dell'half edge end.</p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>half edge di partenza </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>half edge di arrivo, il cui toVertex <b>non</b> <b>è</b> <b>compreso</b> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Avvertimento</dt><dd>Se start e end non risultano avere il vertice this come fromoVertex, viene lanciata un'asserzione e il programma termina </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore che punta al toVertex dell'half edge start </dd></dl>

</div>
</div>
<a id="ac321ceb04d62999b9208ba7996f990b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac321ceb04d62999b9208ba7996f990b7">&sect;&nbsp;</a></span>adjacentVertexBegin() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Vertex_1_1ConstAdjacentVertexIterator.html">Dcel::Vertex::ConstAdjacentVertexIterator</a> Dcel::Vertex::adjacentVertexBegin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDcel_1_1Vertex.html">Dcel::Vertex</a> *&#160;</td>
          <td class="paramname"><em>start</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1ConstAdjacentVertexIterator.html" title="Iteratore che permette di ciclare sui vertici adiacenti ad un vertice, garantendone l&#39;immutabilità...">Dcel::Vertex::ConstAdjacentVertexIterator</a>. </p>
<p>Permette di ciclare sui vertici adiacenti al vertice, partendo dal vertice start.<br />
È meno efficiente rispetto a Dcel::Vertex::constAdjacentVertexBegin(const Dcel::HalfEdge* start).</p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>vertice di partenza </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Avvertimento</dt><dd>Se start non risulta essere adiacente al vertice this (ossia non esiste un half edge condiviso tra this e start), viene lanciata un'asserzione e il programma termina </dd>
<dd>
Utilizza <a class="el" href="classDcel_1_1Vertex_1_1ConstIncomingHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge entranti in un vertice, garantendone l&#39;immutabilità...">Dcel::Vertex::ConstIncomingHalfEdgeIterator</a> </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore che punta al vertice start </dd></dl>
<dl class="section user"><dt>Complessità:</dt><dd><em>O(Cardinality(start))</em> </dd></dl>

</div>
</div>
<a id="aa49c28659041b8e7004b4d4d900aba01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa49c28659041b8e7004b4d4d900aba01">&sect;&nbsp;</a></span>adjacentVertexBegin() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Vertex_1_1ConstAdjacentVertexIterator.html">Dcel::Vertex::ConstAdjacentVertexIterator</a> Dcel::Vertex::adjacentVertexBegin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDcel_1_1Vertex.html">Dcel::Vertex</a> *&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDcel_1_1Vertex.html">Dcel::Vertex</a> *&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1ConstAdjacentVertexIterator.html" title="Iteratore che permette di ciclare sui vertici adiacenti ad un vertice, garantendone l&#39;immutabilità...">Dcel::Vertex::ConstAdjacentVertexIterator</a>. </p>
<p>Permette di ciclare sui vertici adiacenti al vertice, partendo dal vertice start e fino al vertice end.<br />
È meno efficiente rispetto a Dcel::Vertex::constAdjacentVertexBegin(const Dcel::HalfEdge* start, const Dcel::HalfEdge* end).</p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>vertice di partenza </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>vertice di arrivo, <b>non</b> <b>compreso</b> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Avvertimento</dt><dd>Se start e end non risultano essere adiacenti al vertice this (ossia non esiste un half edge condiviso tra this e start e tra this e end), viene lanciata un'asserzione e il programma termina </dd>
<dd>
Utilizza <a class="el" href="classDcel_1_1Vertex_1_1ConstIncomingHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge entranti in un vertice, garantendone l&#39;immutabilità...">Dcel::Vertex::ConstIncomingHalfEdgeIterator</a> </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore che punta al vertice start </dd></dl>
<dl class="section user"><dt>Complessità:</dt><dd><em>O(Cardinality(start))</em> + <em>O(Cardinality(end))</em> </dd></dl>

</div>
</div>
<a id="af625660c1b4ab1efee5c4c494a1d5596"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af625660c1b4ab1efee5c4c494a1d5596">&sect;&nbsp;</a></span>adjacentVertexBegin() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Vertex_1_1AdjacentVertexIterator.html">Dcel::Vertex::AdjacentVertexIterator</a> Dcel::Vertex::adjacentVertexBegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1AdjacentVertexIterator.html" title="Iteratore che permette di ciclare sui vertici adiacenti ad un vertice. ">Dcel::Vertex::AdjacentVertexIterator</a>. </p>
<p>Permette di ciclare sui vertici adiacenti al vertice, partendo dal toVertex dell'incidentHalfEdge.</p>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore che punta al toVertex dell'incidentHalfEdge </dd></dl>

</div>
</div>
<a id="a38680e4442bd79d786cc7b697cff8600"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38680e4442bd79d786cc7b697cff8600">&sect;&nbsp;</a></span>adjacentVertexBegin() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Vertex_1_1AdjacentVertexIterator.html">Dcel::Vertex::AdjacentVertexIterator</a> Dcel::Vertex::adjacentVertexBegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *&#160;</td>
          <td class="paramname"><em>start</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1AdjacentVertexIterator.html" title="Iteratore che permette di ciclare sui vertici adiacenti ad un vertice. ">Dcel::Vertex::AdjacentVertexIterator</a>. </p>
<p>Permette di ciclare sui vertici adiacenti al vertice, partendo dal toVertex dell'half edge start.</p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>half edge di partenza </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Avvertimento</dt><dd>Se start non risulta avere il vertice this come fromoVertex, viene lanciata un'asserzione e il programma termina </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore che punta al toVertex dell'half edge start </dd></dl>

</div>
</div>
<a id="ad89cb5c8e39ac53d35b3c3d46c904667"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad89cb5c8e39ac53d35b3c3d46c904667">&sect;&nbsp;</a></span>adjacentVertexBegin() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Vertex_1_1AdjacentVertexIterator.html">Dcel::Vertex::AdjacentVertexIterator</a> Dcel::Vertex::adjacentVertexBegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1AdjacentVertexIterator.html" title="Iteratore che permette di ciclare sui vertici adiacenti ad un vertice. ">Dcel::Vertex::AdjacentVertexIterator</a>. </p>
<p>Permette di ciclare sui vertici adiacenti al vertice, partendo dal toVertex dell'half edge start e fino al toVertex dell'half edge end.</p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>half edge di partenza </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>half edge di arrivo, il cui toVertex <b>non</b> <b>è</b> <b>compreso</b> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Avvertimento</dt><dd>Se start e end non risultano avere il vertice this come fromoVertex, viene lanciata un'asserzione e il programma termina </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore che punta al toVertex dell'half edge start </dd></dl>

</div>
</div>
<a id="afa0dc803d6d1ebd22a0e50c345e2da5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa0dc803d6d1ebd22a0e50c345e2da5c">&sect;&nbsp;</a></span>adjacentVertexBegin() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Vertex_1_1AdjacentVertexIterator.html">Dcel::Vertex::AdjacentVertexIterator</a> Dcel::Vertex::adjacentVertexBegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDcel_1_1Vertex.html">Dcel::Vertex</a> *&#160;</td>
          <td class="paramname"><em>start</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1AdjacentVertexIterator.html" title="Iteratore che permette di ciclare sui vertici adiacenti ad un vertice. ">Dcel::Vertex::AdjacentVertexIterator</a>. </p>
<p>Permette di ciclare sui vertici adiacenti al vertice, partendo dal vertice start.<br />
È meno efficiente rispetto a Dcel::Vertex::constAdjacentVertexBegin(const Dcel::HalfEdge* start).</p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>vertice di partenza </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Avvertimento</dt><dd>Se start non risulta essere adiacente al vertice this (ossia non esiste un half edge condiviso tra this e start), viene lanciata un'asserzione e il programma termina </dd>
<dd>
Utilizza <a class="el" href="classDcel_1_1Vertex_1_1ConstIncomingHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge entranti in un vertice, garantendone l&#39;immutabilità...">Dcel::Vertex::ConstIncomingHalfEdgeIterator</a> </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore che punta al vertice start </dd></dl>
<dl class="section user"><dt>Complessità:</dt><dd><em>O(Cardinality(start))</em> </dd></dl>

</div>
</div>
<a id="a5748eefe944c0bde7e36c719c5721781"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5748eefe944c0bde7e36c719c5721781">&sect;&nbsp;</a></span>adjacentVertexBegin() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Vertex_1_1AdjacentVertexIterator.html">Dcel::Vertex::AdjacentVertexIterator</a> Dcel::Vertex::adjacentVertexBegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDcel_1_1Vertex.html">Dcel::Vertex</a> *&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDcel_1_1Vertex.html">Dcel::Vertex</a> *&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1AdjacentVertexIterator.html" title="Iteratore che permette di ciclare sui vertici adiacenti ad un vertice. ">Dcel::Vertex::AdjacentVertexIterator</a>. </p>
<p>Permette di ciclare sui vertici adiacenti al vertice, partendo dal vertice start e fino al vertice end.<br />
È meno efficiente rispetto a Dcel::Vertex::constAdjacentVertexBegin(const Dcel::HalfEdge* start, const Dcel::HalfEdge* end).</p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>vertice di partenza </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>vertice di arrivo, <b>non</b> <b>compreso</b> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Avvertimento</dt><dd>Se start e end non risultano essere adiacenti al vertice this (ossia non esiste un half edge condiviso tra this e start e tra this e end), viene lanciata un'asserzione e il programma termina </dd>
<dd>
Utilizza <a class="el" href="classDcel_1_1Vertex_1_1ConstIncomingHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge entranti in un vertice, garantendone l&#39;immutabilità...">Dcel::Vertex::ConstIncomingHalfEdgeIterator</a> </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore che punta al vertice start </dd></dl>
<dl class="section user"><dt>Complessità:</dt><dd><em>O(Cardinality(start))</em> + <em>O(Cardinality(end))</em> </dd></dl>

</div>
</div>
<a id="a1e1f914bf70f81de799cec2977fa7805"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e1f914bf70f81de799cec2977fa7805">&sect;&nbsp;</a></span>adjacentVertexEnd() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Vertex_1_1ConstAdjacentVertexIterator.html">Dcel::Vertex::ConstAdjacentVertexIterator</a> Dcel::Vertex::adjacentVertexEnd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di finalizzazione di <a class="el" href="classDcel_1_1Vertex_1_1ConstAdjacentVertexIterator.html" title="Iteratore che permette di ciclare sui vertici adiacenti ad un vertice, garantendone l&#39;immutabilità...">Dcel::Vertex::ConstAdjacentVertexIterator</a>. </p>
<dl class="section warning"><dt>Avvertimento</dt><dd>L'iteratore restituito non è un iteratore valido, e su di esso le operazioni di incremento e decremento sono inutili. Questa funzione è da utilizzarsi solamente per il <b>confronto</b> <b>con</b> <b>un</b> <b>altro</b> <b>iteratore</b> <b>valido</b> </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore di finalizzazione </dd></dl>

</div>
</div>
<a id="a028641a4f49729dd099c62b364a6c1cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a028641a4f49729dd099c62b364a6c1cf">&sect;&nbsp;</a></span>adjacentVertexEnd() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Vertex_1_1AdjacentVertexIterator.html">Dcel::Vertex::AdjacentVertexIterator</a> Dcel::Vertex::adjacentVertexEnd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di finalizzazione di <a class="el" href="classDcel_1_1Vertex_1_1AdjacentVertexIterator.html" title="Iteratore che permette di ciclare sui vertici adiacenti ad un vertice. ">Dcel::Vertex::AdjacentVertexIterator</a>. </p>
<dl class="section warning"><dt>Avvertimento</dt><dd>L'iteratore restituito non è un iteratore valido, e su di esso le operazioni di incremento e decremento sono inutili. Questa funzione è da utilizzarsi solamente per il <b>confronto</b> <b>con</b> <b>un</b> <b>altro</b> <b>iteratore</b> <b>valido</b> </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore di finalizzazione </dd></dl>

</div>
</div>
<a id="adc0756749e0c536697faf1ae826d133d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc0756749e0c536697faf1ae826d133d">&sect;&nbsp;</a></span>decrementCardinality()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Dcel::Vertex::decrementCardinality </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decrementa la cardinalità del vertice (se essa è maggiore di 0) </p>
<dl class="section return"><dt>Restituisce</dt><dd>La cardinalità decrementata </dd></dl>

</div>
</div>
<a id="aeea51e1990497f38a468637f2e62ff72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeea51e1990497f38a468637f2e62ff72">&sect;&nbsp;</a></span>dist()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double Dcel::Vertex::dist </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDcel_1_1Vertex.html">Dcel::Vertex</a> *&#160;</td>
          <td class="paramname"><em>otherVertex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calcola e restituisce la distanza tra il vertice this e il vertice in input. </p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">otherVertex</td><td>vertice con cui verrà calcolata la distanza dal vertice this </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Restituisce</dt><dd>La distanza tra il vertice this e otherVertex </dd></dl>

</div>
</div>
<a id="a3481a1dbae85fac138e3b97f2a706814"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3481a1dbae85fac138e3b97f2a706814">&sect;&nbsp;</a></span>findSharedHalfEdge() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> * Dcel::Vertex::findSharedHalfEdge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDcel_1_1Vertex.html">Dcel::Vertex</a> *&#160;</td>
          <td class="paramname"><em>vertex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione che cerca e restituisce l'half edge costante condiviso dal vertice this e vertex. </p>
<p>Nello specifico, se viene cercato l'half edge che ha come origine il vertice this e come destinazione il vertice in input vertex. Se l'half edge non viene trovato (non esiste un half edge condiviso dai due vertici) viene restituito nullptr;</p>
<dl class="section warning"><dt>Avvertimento</dt><dd>Utilizza <a class="el" href="classDcel_1_1Vertex_1_1ConstOutgoingHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge uscenti da un vertice, garantendone l&#39;immutabilità...">Dcel::Vertex::ConstOutgoingHalfEdgeIterator</a> </dd></dl>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vertex</td><td>vertice con cui viene cercato l'half edge condiviso </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Restituisce</dt><dd>l'half edge condiviso se esiste, nullptr altrimenti </dd></dl>
<dl class="section user"><dt>Complessità:</dt><dd><em>O(Cardinality)</em> </dd></dl>

</div>
</div>
<a id="a8f3c7f3495daa71a2a2b72ecde413210"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f3c7f3495daa71a2a2b72ecde413210">&sect;&nbsp;</a></span>findSharedHalfEdge() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> * Dcel::Vertex::findSharedHalfEdge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDcel_1_1Vertex.html">Dcel::Vertex</a> *&#160;</td>
          <td class="paramname"><em>vertex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione che cerca e restituisce l'half edge condiviso dal vertice this e vertex. </p>
<p>Nello specifico, se viene cercato l'half edge che ha come origine il vertice this e come destinazione il vertice in input vertex. Se l'half edge non viene trovato (non esiste un half edge condiviso dai due vertici) viene restituito nullptr;</p>
<dl class="section warning"><dt>Avvertimento</dt><dd>Utilizza <a class="el" href="classDcel_1_1Vertex_1_1OutgoingHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge uscenti da un vertice. ">Dcel::Vertex::OutgoingHalfEdgeIterator</a> </dd></dl>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vertex</td><td>vertice con cui viene cercato l'half edge condiviso </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Restituisce</dt><dd>l'half edge condiviso se esiste, nullptr altrimenti </dd></dl>
<dl class="section user"><dt>Complessità:</dt><dd><em>O(Cardinality)</em> </dd></dl>

</div>
</div>
<a id="ac117e101196d703a3004319171b36c3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac117e101196d703a3004319171b36c3f">&sect;&nbsp;</a></span>getCardinality()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Dcel::Vertex::getCardinality </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restituisce il numero di edge incidenti sul vertice. </p>
<dl class="section note"><dt>Nota</dt><dd>Non ricalcola la cardinalità, restituisce solo l'ultima cardinalità calcolata o settata </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>La cardinalità del vertice </dd></dl>

</div>
</div>
<a id="ada77901c0ffb081ea5799e0a25e47b50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada77901c0ffb081ea5799e0a25e47b50">&sect;&nbsp;</a></span>getCoordinate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Pointd</a> Dcel::Vertex::getCoordinate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restituisce le coordinate del vertice. </p>
<dl class="section return"><dt>Restituisce</dt><dd>Pointd rappresentante la posizione nello spazio del vertice </dd></dl>

</div>
</div>
<a id="a2959403f49c0e290ac9089429d5138b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2959403f49c0e290ac9089429d5138b5">&sect;&nbsp;</a></span>getFlag()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Dcel::Vertex::getFlag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restituisce il flag associato al vertice. </p>
<dl class="section return"><dt>Restituisce</dt><dd>Il flag del vertice </dd></dl>

</div>
</div>
<a id="ad37cd4f73b74fb445dfde68ec28e8dff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad37cd4f73b74fb445dfde68ec28e8dff">&sect;&nbsp;</a></span>getId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Dcel::Vertex::getId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restirìtuisce l'id identificativo nella <a class="el" href="classDcel.html" title="Struttura dati Double Conntected Edge List. ">Dcel</a> del vertice. </p>
<dl class="section return"><dt>Restituisce</dt><dd>L'id del vertice </dd></dl>

</div>
</div>
<a id="a5f9c69fd35ed7350f28cacf7606e8181"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f9c69fd35ed7350f28cacf7606e8181">&sect;&nbsp;</a></span>getIncidentHalfEdge() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> * Dcel::Vertex::getIncidentHalfEdge </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restituisce il puntatore l'half edge costante incidente sul vertice. </p>
<dl class="section return"><dt>Restituisce</dt><dd>L'<a class="el" href="classDcel_1_1HalfEdge.html" title="Classe rappresentante un half edge della Dcel. ">HalfEdge</a> incidente sul vertice </dd></dl>

</div>
</div>
<a id="a0a949ee8a2fcace2c112238586f13daf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a949ee8a2fcace2c112238586f13daf">&sect;&nbsp;</a></span>getIncidentHalfEdge() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> * Dcel::Vertex::getIncidentHalfEdge </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restituisce il puntatore all'half edge incidente sul vertice. </p>
<dl class="section return"><dt>Restituisce</dt><dd>L'<a class="el" href="classDcel_1_1HalfEdge.html" title="Classe rappresentante un half edge della Dcel. ">HalfEdge</a> incidente sul vertice </dd></dl>

</div>
</div>
<a id="ab12daad67777575b0cd7aa734a5e72e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab12daad67777575b0cd7aa734a5e72e8">&sect;&nbsp;</a></span>getNormal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Vec3</a> Dcel::Vertex::getNormal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restituisce il vettore normale al vertice. </p>
<dl class="section note"><dt>Nota</dt><dd>Non ricalcola la normale, restituisce solo l'ultima normale calcolata o settata </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>La normale al vertice </dd></dl>

</div>
</div>
<a id="aac15392ca761019534eff4dde147bc6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac15392ca761019534eff4dde147bc6c">&sect;&nbsp;</a></span>getNumberAdjacentVertices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Dcel::Vertex::getNumberAdjacentVertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calcola e restituisce il numero di vertici adiacenti al vertice. </p>
<dl class="section warning"><dt>Avvertimento</dt><dd>Utilizza <a class="el" href="classDcel_1_1Vertex_1_1ConstAdjacentVertexIterator.html" title="Iteratore che permette di ciclare sui vertici adiacenti ad un vertice, garantendone l&#39;immutabilità...">Dcel::Vertex::ConstAdjacentVertexIterator</a> </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>Il numero di vertici adiacenti al vertice </dd></dl>
<dl class="section user"><dt>Complessità:</dt><dd><em>O(Cardinality)</em> </dd></dl>

</div>
</div>
<a id="af6143f25470f9b18fdd82f393390bde7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6143f25470f9b18fdd82f393390bde7">&sect;&nbsp;</a></span>getNumberIncidentFaces()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Dcel::Vertex::getNumberIncidentFaces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calcola e restituisce il numero di facce incidenti sul vertice. </p>
<dl class="section note"><dt>Nota</dt><dd>Se un'unica faccia incide sul vertice due volte, questa verrà contata due volte </dd></dl>
<dl class="section warning"><dt>Avvertimento</dt><dd>Utilizza <a class="el" href="classDcel_1_1Vertex_1_1ConstIncidentFaceIterator.html" title="Iteratore che permette di ciclare sulle facce incidenti su un vertice. ">Dcel::Vertex::ConstIncidentFaceIterator</a> </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>Il numero di facce incidenti sul vertice </dd></dl>
<dl class="section user"><dt>Complessità:</dt><dd><em>O(Cardinality)</em> </dd></dl>

</div>
</div>
<a id="a31a432e6e0946b2a37dfa6d64ca318be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31a432e6e0946b2a37dfa6d64ca318be">&sect;&nbsp;</a></span>getNumberIncidentHalfEdges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Dcel::Vertex::getNumberIncidentHalfEdges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calcola e restituisce il numero di half edge (non di edge) incidenti sul vertice. </p>
<dl class="section warning"><dt>Avvertimento</dt><dd>Utilizza <a class="el" href="classDcel_1_1Vertex_1_1ConstIncidentHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge uscenti e entranti in un vertice. ">Dcel::Vertex::ConstIncidentHalfEdgeIterator</a> </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>Il numero di edge incidenti sul vertice </dd></dl>
<dl class="section user"><dt>Complessità:</dt><dd><em>O(Cardinality)</em> </dd></dl>

</div>
</div>
<a id="a46aafc7a3284fff47fe9c53e295bf7d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46aafc7a3284fff47fe9c53e295bf7d2">&sect;&nbsp;</a></span>incidentFaceBegin() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Vertex_1_1ConstIncidentFaceIterator.html">Dcel::Vertex::ConstIncidentFaceIterator</a> Dcel::Vertex::incidentFaceBegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1ConstIncidentFaceIterator.html" title="Iteratore che permette di ciclare sulle facce incidenti su un vertice. ">Dcel::Vertex::ConstIncidentFaceIterator</a>. </p>
<p>Permette di ciclare sulle facce incidenti sul vertice, partendo dalla faccia incidente sull'incidentHalfEdge.</p>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore che punta alla faccia incidente sull'incidentHalfEdge del vertice </dd></dl>

</div>
</div>
<a id="a30b9541b9d8e703f286b186a261ba187"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30b9541b9d8e703f286b186a261ba187">&sect;&nbsp;</a></span>incidentFaceBegin() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Vertex_1_1ConstIncidentFaceIterator.html">Dcel::Vertex::ConstIncidentFaceIterator</a> Dcel::Vertex::incidentFaceBegin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *&#160;</td>
          <td class="paramname"><em>start</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1ConstIncidentFaceIterator.html" title="Iteratore che permette di ciclare sulle facce incidenti su un vertice. ">Dcel::Vertex::ConstIncidentFaceIterator</a>. </p>
<p>Permette di ciclare sulle facce incidenti sul vertice, partendo dalla faccia incidente sull'half edge start.</p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>half edge di partenza </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Avvertimento</dt><dd>Se start non risulta avere il vertice this come fromVertex, viene lanciata un'asserzione e il programma termina </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore che punta alla faccia incidente sull'half edge start </dd></dl>

</div>
</div>
<a id="ad736f5ba65d134dc7781e7bbfdf3776b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad736f5ba65d134dc7781e7bbfdf3776b">&sect;&nbsp;</a></span>incidentFaceBegin() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Vertex_1_1ConstIncidentFaceIterator.html">Dcel::Vertex::ConstIncidentFaceIterator</a> Dcel::Vertex::incidentFaceBegin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1ConstIncidentFaceIterator.html" title="Iteratore che permette di ciclare sulle facce incidenti su un vertice. ">Dcel::Vertex::ConstIncidentFaceIterator</a>. </p>
<p>Permette di ciclare sulle facce incidenti sul vertice, partendo dalla faccia incidente sull'half edge start e fino alla faccia incidente sull'half edge end.</p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>half edge di partenza </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>half edge di arrivo, che <b>non</b> <b>è</b> <b>compreso</b> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Avvertimento</dt><dd>Se start e end non risultano avere il vertice this come fromVertex, viene lanciata un'asserzione e il programma termina </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore che punta alla faccia incidente sull'half edge start </dd></dl>

</div>
</div>
<a id="ae15c9bc16b4d82ec9fbac027b43f3f15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae15c9bc16b4d82ec9fbac027b43f3f15">&sect;&nbsp;</a></span>incidentFaceBegin() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Vertex_1_1IncidentFaceIterator.html">Dcel::Vertex::IncidentFaceIterator</a> Dcel::Vertex::incidentFaceBegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1IncidentFaceIterator.html" title="Iteratore che permette di ciclare sulle facce incidenti su un vertice. ">Dcel::Vertex::IncidentFaceIterator</a>. </p>
<p>Permette di ciclare sulle facce incidenti sul vertice, partendo dalla faccia incidente sull'incidentHalfEdge.</p>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore che punta alla faccia incidente sull'incidentHalfEdge del vertice </dd></dl>

</div>
</div>
<a id="a37dd8578f18308f9d111919935596727"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37dd8578f18308f9d111919935596727">&sect;&nbsp;</a></span>incidentFaceBegin() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Vertex_1_1IncidentFaceIterator.html">Dcel::Vertex::IncidentFaceIterator</a> Dcel::Vertex::incidentFaceBegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *&#160;</td>
          <td class="paramname"><em>start</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1IncidentFaceIterator.html" title="Iteratore che permette di ciclare sulle facce incidenti su un vertice. ">Dcel::Vertex::IncidentFaceIterator</a>. </p>
<p>Permette di ciclare sulle facce incidenti sul vertice, partendo dalla faccia incidente sull'half edge start.</p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>half edge di partenza </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Avvertimento</dt><dd>Se start non risulta avere il vertice this come fromVertex, viene lanciata un'asserzione e il programma termina </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore che punta alla faccia incidente sull'half edge start </dd></dl>

</div>
</div>
<a id="a1699e2df8c65baf04b7ed3fbc7293d14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1699e2df8c65baf04b7ed3fbc7293d14">&sect;&nbsp;</a></span>incidentFaceBegin() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Vertex_1_1IncidentFaceIterator.html">Dcel::Vertex::IncidentFaceIterator</a> Dcel::Vertex::incidentFaceBegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1IncidentFaceIterator.html" title="Iteratore che permette di ciclare sulle facce incidenti su un vertice. ">Dcel::Vertex::IncidentFaceIterator</a>. </p>
<p>Permette di ciclare sulle facce incidenti sul vertice, partendo dalla faccia incidente sull'half edge start e fino alla faccia incidente sull'half edge end.</p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>half edge di partenza </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>half edge di arrivo, che <b>non</b> <b>è</b> <b>compreso</b> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Avvertimento</dt><dd>Se start e end non risultano avere il vertice this come fromVertex, viene lanciata un'asserzione e il programma termina </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore che punta alla faccia incidente sull'half edge start </dd></dl>

</div>
</div>
<a id="abc514003dac6cc6237648d5951d78b0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc514003dac6cc6237648d5951d78b0c">&sect;&nbsp;</a></span>incidentFaceEnd() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Vertex_1_1ConstIncidentFaceIterator.html">Dcel::Vertex::ConstIncidentFaceIterator</a> Dcel::Vertex::incidentFaceEnd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di finalizzazione di <a class="el" href="classDcel_1_1Vertex_1_1ConstIncidentFaceIterator.html" title="Iteratore che permette di ciclare sulle facce incidenti su un vertice. ">Dcel::Vertex::ConstIncidentFaceIterator</a>. </p>
<dl class="section warning"><dt>Avvertimento</dt><dd>L'iteratore restituito non è un iteratore valido, e su di esso le operazioni di incremento e decremento sono inutili. Questa funzione è da utilizzarsi solamente per il <b>confronto</b> <b>con</b> <b>un</b> <b>altro</b> <b>iteratore</b> <b>valido</b> </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore di finalizzazione </dd></dl>

</div>
</div>
<a id="a6c7884f95c62825149bc2c8a09844219"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c7884f95c62825149bc2c8a09844219">&sect;&nbsp;</a></span>incidentFaceEnd() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Vertex_1_1IncidentFaceIterator.html">Dcel::Vertex::IncidentFaceIterator</a> Dcel::Vertex::incidentFaceEnd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di finalizzazione di <a class="el" href="classDcel_1_1Vertex_1_1IncidentFaceIterator.html" title="Iteratore che permette di ciclare sulle facce incidenti su un vertice. ">Dcel::Vertex::IncidentFaceIterator</a>. </p>
<dl class="section warning"><dt>Avvertimento</dt><dd>L'iteratore restituito non è un iteratore valido, e su di esso le operazioni di incremento e decremento sono inutili. Questa funzione è da utilizzarsi solamente per il <b>confronto</b> <b>con</b> <b>un</b> <b>altro</b> <b>iteratore</b> <b>valido</b> </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore di finalizzazione </dd></dl>

</div>
</div>
<a id="a8d259c52bf838c3ae79543cceea74a0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d259c52bf838c3ae79543cceea74a0d">&sect;&nbsp;</a></span>incidentHalfEdgeBegin() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Vertex_1_1ConstIncidentHalfEdgeIterator.html">Dcel::Vertex::ConstIncidentHalfEdgeIterator</a> Dcel::Vertex::incidentHalfEdgeBegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1ConstIncidentHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge uscenti e entranti in un vertice. ">Dcel::Vertex::ConstIncidentHalfEdgeIterator</a>. </p>
<p>Permette di ciclare sugli half edge incidenti, sia uscenti che entranti nel vertice, partendo dall'incidentHalfEdge.</p>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore che punta all'incidentHalfEdge del vertice </dd></dl>

</div>
</div>
<a id="a518c0c0b03a69bcd5594c19535dd9eb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a518c0c0b03a69bcd5594c19535dd9eb4">&sect;&nbsp;</a></span>incidentHalfEdgeBegin() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Vertex_1_1ConstIncidentHalfEdgeIterator.html">Dcel::Vertex::ConstIncidentHalfEdgeIterator</a> Dcel::Vertex::incidentHalfEdgeBegin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *&#160;</td>
          <td class="paramname"><em>start</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1ConstIncidentHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge uscenti e entranti in un vertice. ">Dcel::Vertex::ConstIncidentHalfEdgeIterator</a>. </p>
<p>Permette di ciclare sugli half edge incidenti uscenti e entranti nel vertice, partendo dall'half edge start.</p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>half edge di partenza </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Avvertimento</dt><dd>Se start non risulta avere il vertice this come toVertex o fromVertex, viene lanciata un'asserzione e il programma termina </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore che punta all'half edge start </dd></dl>

</div>
</div>
<a id="a082b59791d3c94fc7554c9af92513298"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a082b59791d3c94fc7554c9af92513298">&sect;&nbsp;</a></span>incidentHalfEdgeBegin() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Vertex_1_1ConstIncidentHalfEdgeIterator.html">Dcel::Vertex::ConstIncidentHalfEdgeIterator</a> Dcel::Vertex::incidentHalfEdgeBegin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1ConstIncidentHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge uscenti e entranti in un vertice. ">Dcel::Vertex::ConstIncidentHalfEdgeIterator</a>. </p>
<p>Permette di ciclare sugli half edge incidenti uscenti e entranti nel vertice, partendo dall'half edge start e fino all'half edge end.</p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>half edge di partenza </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>half edge di arrivo, che <b>non</b> <b>è</b> <b>compreso</b> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Avvertimento</dt><dd>Se start e end non risultano avere il vertice this come toVertex o fromVertex, viene lanciata un'asserzione e il programma termina </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore che punta all'half edge start </dd></dl>

</div>
</div>
<a id="a90f1a9cf6aefb84daca8768c74471c72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90f1a9cf6aefb84daca8768c74471c72">&sect;&nbsp;</a></span>incidentHalfEdgeBegin() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Vertex_1_1IncidentHalfEdgeIterator.html">Dcel::Vertex::IncidentHalfEdgeIterator</a> Dcel::Vertex::incidentHalfEdgeBegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1IncidentHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge uscenti e entranti in un vertice. ">Dcel::Vertex::IncidentHalfEdgeIterator</a>. </p>
<p>Permette di ciclare sugli half edge incidenti, sia uscenti che entranti nel vertice, partendo dall'incidentHalfEdge.</p>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore che punta all'incidentHalfEdge del vertice </dd></dl>

</div>
</div>
<a id="ac8f34fdd1b9fbc78f27cfcc7b8d91e11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8f34fdd1b9fbc78f27cfcc7b8d91e11">&sect;&nbsp;</a></span>incidentHalfEdgeBegin() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Vertex_1_1IncidentHalfEdgeIterator.html">Dcel::Vertex::IncidentHalfEdgeIterator</a> Dcel::Vertex::incidentHalfEdgeBegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *&#160;</td>
          <td class="paramname"><em>start</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1IncidentHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge uscenti e entranti in un vertice. ">Dcel::Vertex::IncidentHalfEdgeIterator</a>. </p>
<p>Permette di ciclare sugli half edge incidenti uscenti e entranti nel vertice, partendo dall'half edge start.</p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>half edge di partenza </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Avvertimento</dt><dd>Se start non risulta avere il vertice this come toVertex o fromVertex, viene lanciata un'asserzione e il programma termina </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore che punta all'half edge start </dd></dl>

</div>
</div>
<a id="af7ca1be7938dec64f0008eef461622bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7ca1be7938dec64f0008eef461622bb">&sect;&nbsp;</a></span>incidentHalfEdgeBegin() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Vertex_1_1IncidentHalfEdgeIterator.html">Dcel::Vertex::IncidentHalfEdgeIterator</a> Dcel::Vertex::incidentHalfEdgeBegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1IncidentHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge uscenti e entranti in un vertice. ">Dcel::Vertex::IncidentHalfEdgeIterator</a>. </p>
<p>Permette di ciclare sugli half edge incidenti uscenti e entranti nel vertice, partendo dall'half edge start e fino all'half edge end.</p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>half edge di partenza </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>half edge di arrivo, che <b>non</b> <b>è</b> <b>compreso</b> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Avvertimento</dt><dd>Se start e end non risultano avere il vertice this come toVertex o fromVertex, viene lanciata un'asserzione e il programma termina </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore che punta all'half edge start </dd></dl>

</div>
</div>
<a id="aa79b7a35742590461fe3314df86aac8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa79b7a35742590461fe3314df86aac8d">&sect;&nbsp;</a></span>incidentHalfEdgeEnd() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Vertex_1_1ConstIncidentHalfEdgeIterator.html">Dcel::Vertex::ConstIncidentHalfEdgeIterator</a> Dcel::Vertex::incidentHalfEdgeEnd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di finalizzazione di <a class="el" href="classDcel_1_1Vertex_1_1ConstIncidentHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge uscenti e entranti in un vertice. ">Dcel::Vertex::ConstIncidentHalfEdgeIterator</a>. </p>
<dl class="section warning"><dt>Avvertimento</dt><dd>L'iteratore restituito non è un iteratore valido, e su di esso le operazioni di incremento e decremento sono inutili. Questa funzione è da utilizzarsi solamente per il <b>confronto</b> <b>con</b> <b>un</b> <b>altro</b> <b>iteratore</b> <b>valido</b> </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore di finalizzazione </dd></dl>

</div>
</div>
<a id="a68a94f4290722b3b5e635170a42976a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68a94f4290722b3b5e635170a42976a5">&sect;&nbsp;</a></span>incidentHalfEdgeEnd() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Vertex_1_1IncidentHalfEdgeIterator.html">Dcel::Vertex::IncidentHalfEdgeIterator</a> Dcel::Vertex::incidentHalfEdgeEnd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di finalizzazione di <a class="el" href="classDcel_1_1Vertex_1_1IncidentHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge uscenti e entranti in un vertice. ">Dcel::Vertex::IncidentHalfEdgeIterator</a>. </p>
<dl class="section warning"><dt>Avvertimento</dt><dd>L'iteratore restituito non è un iteratore valido, e su di esso le operazioni di incremento e decremento sono inutili. Questa funzione è da utilizzarsi solamente per il <b>confronto</b> <b>con</b> <b>un</b> <b>altro</b> <b>iteratore</b> <b>valido</b> </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore di finalizzazione </dd></dl>

</div>
</div>
<a id="a2b4bfb4d2931d387798ec245238b1cd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b4bfb4d2931d387798ec245238b1cd9">&sect;&nbsp;</a></span>incomingHalfEdgeBegin() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Vertex_1_1ConstIncomingHalfEdgeIterator.html">Dcel::Vertex::ConstIncomingHalfEdgeIterator</a> Dcel::Vertex::incomingHalfEdgeBegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1ConstIncomingHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge entranti in un vertice, garantendone l&#39;immutabilità...">Dcel::Vertex::ConstIncomingHalfEdgeIterator</a>. </p>
<p>Permette di ciclare sugli half edge incidenti entranti nel vertice, partendo dal twin dell'incidentHalfEdge.</p>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore che punta al twin dell'incidentHalfEdge del vertice </dd></dl>

</div>
</div>
<a id="a98ca422a0e54443e40de401af868158f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98ca422a0e54443e40de401af868158f">&sect;&nbsp;</a></span>incomingHalfEdgeBegin() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Vertex_1_1ConstIncomingHalfEdgeIterator.html">Dcel::Vertex::ConstIncomingHalfEdgeIterator</a> Dcel::Vertex::incomingHalfEdgeBegin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *&#160;</td>
          <td class="paramname"><em>start</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1ConstIncomingHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge entranti in un vertice, garantendone l&#39;immutabilità...">Dcel::Vertex::ConstIncomingHalfEdgeIterator</a>. </p>
<p>Permette di ciclare sugli half edge incidenti entranti nel vertice, partendo dall'half edge start.</p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>half edge di partenza </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Avvertimento</dt><dd>Se start non risulta avere il vertice this come toVertex, viene lanciata un'asserzione e il programma termina </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore che punta all'half edge start </dd></dl>

</div>
</div>
<a id="af15f36f08bc13ddbe09257fdd72c1d49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af15f36f08bc13ddbe09257fdd72c1d49">&sect;&nbsp;</a></span>incomingHalfEdgeBegin() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Vertex_1_1ConstIncomingHalfEdgeIterator.html">Dcel::Vertex::ConstIncomingHalfEdgeIterator</a> Dcel::Vertex::incomingHalfEdgeBegin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1ConstIncomingHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge entranti in un vertice, garantendone l&#39;immutabilità...">Dcel::Vertex::ConstIncomingHalfEdgeIterator</a>. </p>
<p>Permette di ciclare sugli half edge incidenti entranti nel vertice, partendo dall'half edge start e fino all'half edge end.</p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>half edge di partenza </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>half edge di arrivo, che <b>non</b> <b>è</b> <b>compreso</b> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Avvertimento</dt><dd>Se start e end non risultano avere il vertice this come toVertex, viene lanciata un'asserzione e il programma termina </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore che punta all'half edge start </dd></dl>

</div>
</div>
<a id="a2520372b90e7700f1c3ad5efcf86485c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2520372b90e7700f1c3ad5efcf86485c">&sect;&nbsp;</a></span>incomingHalfEdgeBegin() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Vertex_1_1IncomingHalfEdgeIterator.html">Dcel::Vertex::IncomingHalfEdgeIterator</a> Dcel::Vertex::incomingHalfEdgeBegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1IncomingHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge entranti in un vertice. ">Dcel::Vertex::IncomingHalfEdgeIterator</a>. </p>
<p>Permette di ciclare sugli half edge incidenti entranti nel vertice, partendo dal twin dell'incidentHalfEdge.</p>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore che punta al twin dell'incidentHalfEdge del vertice </dd></dl>

</div>
</div>
<a id="afcb79cd6f3e85146eac1ecd7bae72cf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcb79cd6f3e85146eac1ecd7bae72cf0">&sect;&nbsp;</a></span>incomingHalfEdgeBegin() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Vertex_1_1IncomingHalfEdgeIterator.html">Dcel::Vertex::IncomingHalfEdgeIterator</a> Dcel::Vertex::incomingHalfEdgeBegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *&#160;</td>
          <td class="paramname"><em>start</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1IncomingHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge entranti in un vertice. ">Dcel::Vertex::IncomingHalfEdgeIterator</a>. </p>
<p>Permette di ciclare sugli half edge incidenti entranti nel vertice, partendo dall'half edge start.</p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>half edge di partenza </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Avvertimento</dt><dd>Se start non risulta avere il vertice this come toVertex, viene lanciata un'asserzione e il programma termina </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore che punta all'half edge start </dd></dl>

</div>
</div>
<a id="a572ed133e758f8c9c7744b9a4947b037"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a572ed133e758f8c9c7744b9a4947b037">&sect;&nbsp;</a></span>incomingHalfEdgeBegin() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Vertex_1_1IncomingHalfEdgeIterator.html">Dcel::Vertex::IncomingHalfEdgeIterator</a> Dcel::Vertex::incomingHalfEdgeBegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1IncomingHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge entranti in un vertice. ">Dcel::Vertex::IncomingHalfEdgeIterator</a>. </p>
<p>Permette di ciclare sugli half edge incidenti entranti nel vertice, partendo dall'half edge start e fino all'half edge end.</p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>half edge di partenza </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>half edge di arrivo, che <b>non</b> <b>è</b> <b>compreso</b> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Avvertimento</dt><dd>Se start e end non risultano avere il vertice this come toVertex, viene lanciata un'asserzione e il programma termina </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore che punta all'half edge start </dd></dl>

</div>
</div>
<a id="a689e9e08818c7167bcbd34d92c73d6a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a689e9e08818c7167bcbd34d92c73d6a1">&sect;&nbsp;</a></span>incomingHalfEdgeEnd() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Vertex_1_1ConstIncomingHalfEdgeIterator.html">Dcel::Vertex::ConstIncomingHalfEdgeIterator</a> Dcel::Vertex::incomingHalfEdgeEnd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di finalizzazione di <a class="el" href="classDcel_1_1Vertex_1_1ConstIncomingHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge entranti in un vertice, garantendone l&#39;immutabilità...">Dcel::Vertex::ConstIncomingHalfEdgeIterator</a>. </p>
<dl class="section warning"><dt>Avvertimento</dt><dd>L'iteratore restituito non è un iteratore valido, e su di esso le operazioni di incremento e decremento sono inutili. Questa funzione è da utilizzarsi solamente per il <b>confronto</b> <b>con</b> <b>un</b> <b>altro</b> <b>iteratore</b> <b>valido</b> </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore di finalizzazione </dd></dl>

</div>
</div>
<a id="aeacd416c59aef198db8fa8507fa43b11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeacd416c59aef198db8fa8507fa43b11">&sect;&nbsp;</a></span>incomingHalfEdgeEnd() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Vertex_1_1IncomingHalfEdgeIterator.html">Dcel::Vertex::IncomingHalfEdgeIterator</a> Dcel::Vertex::incomingHalfEdgeEnd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di finalizzazione di <a class="el" href="classDcel_1_1Vertex_1_1IncomingHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge entranti in un vertice. ">Dcel::Vertex::IncomingHalfEdgeIterator</a>. </p>
<dl class="section warning"><dt>Avvertimento</dt><dd>L'iteratore restituito non è un iteratore valido, e su di esso le operazioni di incremento e decremento sono inutili. Questa funzione è da utilizzarsi solamente per il <b>confronto</b> <b>con</b> <b>un</b> <b>altro</b> <b>iteratore</b> <b>valido</b> </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore di finalizzazione </dd></dl>

</div>
</div>
<a id="a7d8c450e431fd8babcdb7cfdf517b8fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d8c450e431fd8babcdb7cfdf517b8fa">&sect;&nbsp;</a></span>incrementCardinality()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Dcel::Vertex::incrementCardinality </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Incrementa la cardinalità del vertice. </p>
<dl class="section return"><dt>Restituisce</dt><dd>La cardinalità incrementata </dd></dl>

</div>
</div>
<a id="aebded11891b2bdf5fd183598113a1aae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebded11891b2bdf5fd183598113a1aae">&sect;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Dcel::Vertex::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDcel_1_1Vertex.html">Dcel::Vertex</a> &amp;&#160;</td>
          <td class="paramname"><em>othervertex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Operatore di disuguaglianza tra vertici. </p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">otherVertex</td><td>vertice con cui verrà verificata la disuguaglianza con la faccia this </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Restituisce</dt><dd>True se i vertici sono diversi, false altrimenti </dd></dl>

</div>
</div>
<a id="acee633c3e4a21a0638cc4c0d11300578"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acee633c3e4a21a0638cc4c0d11300578">&sect;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Dcel::Vertex::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDcel_1_1Vertex.html">Dcel::Vertex</a> &amp;&#160;</td>
          <td class="paramname"><em>otherVertex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Operatore di uguaglianza tra vertici. </p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">otherVertex</td><td>vertice con cui verrà verificata l'uguaglianza con la faccia this </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Restituisce</dt><dd>True se i vertici sono uguali, false altrimenti </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000012">Da fare:</a></b></dt><dd>Da riscrivere </dd></dl>

</div>
</div>
<a id="a89d29f126177950bf47fc6711f15977d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89d29f126177950bf47fc6711f15977d">&sect;&nbsp;</a></span>outgoingHalfEdgeBegin() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Vertex_1_1ConstOutgoingHalfEdgeIterator.html">Dcel::Vertex::ConstOutgoingHalfEdgeIterator</a> Dcel::Vertex::outgoingHalfEdgeBegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1ConstOutgoingHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge uscenti da un vertice, garantendone l&#39;immutabilità...">Dcel::Vertex::ConstOutgoingHalfEdgeIterator</a>. </p>
<p>Permette di ciclare sugli half edge incidenti uscenti dal vertice, partendo dall'incidentHalfEdge.</p>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore che punta all'incidentHalfEdge del vertice </dd></dl>

</div>
</div>
<a id="a5e306e44023dcc1de3e96ba13141a2af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e306e44023dcc1de3e96ba13141a2af">&sect;&nbsp;</a></span>outgoingHalfEdgeBegin() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Vertex_1_1ConstOutgoingHalfEdgeIterator.html">Dcel::Vertex::ConstOutgoingHalfEdgeIterator</a> Dcel::Vertex::outgoingHalfEdgeBegin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *&#160;</td>
          <td class="paramname"><em>start</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1ConstOutgoingHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge uscenti da un vertice, garantendone l&#39;immutabilità...">Dcel::Vertex::ConstOutgoingHalfEdgeIterator</a>. </p>
<p>Permette di ciclare sugli half edge incidenti uscenti dal vertice, partendo dall'half edge start.</p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>half edge di partenza </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Avvertimento</dt><dd>Se start non risulta avere il vertice this come fromVertex, viene lanciata un'asserzione e il programma termina </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore che punta all'half edge start </dd></dl>

</div>
</div>
<a id="aecd4db28ae400bd6eab79060a4a736a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecd4db28ae400bd6eab79060a4a736a6">&sect;&nbsp;</a></span>outgoingHalfEdgeBegin() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Vertex_1_1ConstOutgoingHalfEdgeIterator.html">Dcel::Vertex::ConstOutgoingHalfEdgeIterator</a> Dcel::Vertex::outgoingHalfEdgeBegin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1ConstOutgoingHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge uscenti da un vertice, garantendone l&#39;immutabilità...">Dcel::Vertex::ConstOutgoingHalfEdgeIterator</a>. </p>
<p>Permette di ciclare sugli half edge incidenti uscenti dal vertice, partendo dall'half edge start e fino all'half edge end.</p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>half edge di partenza </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>half edge di arrivo, che <b>non</b> <b>è</b> <b>compreso</b> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Avvertimento</dt><dd>Se start e end non risultano avere il vertice this come fromVertex, viene lanciata un'asserzione e il programma termina </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore che punta all'half edge start </dd></dl>

</div>
</div>
<a id="a51ad4d92f2a1dabea8dba215858794b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51ad4d92f2a1dabea8dba215858794b5">&sect;&nbsp;</a></span>outgoingHalfEdgeBegin() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Vertex_1_1OutgoingHalfEdgeIterator.html">Dcel::Vertex::OutgoingHalfEdgeIterator</a> Dcel::Vertex::outgoingHalfEdgeBegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1OutgoingHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge uscenti da un vertice. ">Dcel::Vertex::OutgoingHalfEdgeIterator</a>. </p>
<p>Permette di ciclare sugli half edge incidenti uscenti dal vertice, partendo dall'incidentHalfEdge.</p>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore che punta all'incidentHalfEdge del vertice </dd></dl>

</div>
</div>
<a id="aa818fa51cc350dd63e3b16666339632d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa818fa51cc350dd63e3b16666339632d">&sect;&nbsp;</a></span>outgoingHalfEdgeBegin() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Vertex_1_1OutgoingHalfEdgeIterator.html">Dcel::Vertex::OutgoingHalfEdgeIterator</a> Dcel::Vertex::outgoingHalfEdgeBegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *&#160;</td>
          <td class="paramname"><em>start</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1OutgoingHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge uscenti da un vertice. ">Dcel::Vertex::OutgoingHalfEdgeIterator</a>. </p>
<p>Permette di ciclare sugli half edge incidenti uscenti dal vertice, partendo dall'half edge start.</p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>half edge di partenza </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Avvertimento</dt><dd>Se start non risulta avere il vertice this come fromVertex, viene lanciata un'asserzione e il programma termina </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore che punta all'half edge start </dd></dl>

</div>
</div>
<a id="a521ec35b8c0bf0fc04ccda8daaf0b1ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a521ec35b8c0bf0fc04ccda8daaf0b1ec">&sect;&nbsp;</a></span>outgoingHalfEdgeBegin() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Vertex_1_1OutgoingHalfEdgeIterator.html">Dcel::Vertex::OutgoingHalfEdgeIterator</a> Dcel::Vertex::outgoingHalfEdgeBegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di inizializzazione di <a class="el" href="classDcel_1_1Vertex_1_1OutgoingHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge uscenti da un vertice. ">Dcel::Vertex::OutgoingHalfEdgeIterator</a>. </p>
<p>Permette di ciclare sugli half edge incidenti uscenti dal vertice, partendo dall'half edge start e fino all'half edge end.</p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>half edge di partenza </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>half edge di arrivo, che <b>non</b> <b>è</b> <b>compreso</b> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Avvertimento</dt><dd>Se start e end non risultano avere il vertice this come fromVertex, viene lanciata un'asserzione e il programma termina </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore che punta all'half edge start </dd></dl>

</div>
</div>
<a id="a56446fd2de159875eed63b24eccda78e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56446fd2de159875eed63b24eccda78e">&sect;&nbsp;</a></span>outgoingHalfEdgeEnd() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Vertex_1_1ConstOutgoingHalfEdgeIterator.html">Dcel::Vertex::ConstOutgoingHalfEdgeIterator</a> Dcel::Vertex::outgoingHalfEdgeEnd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di finalizzazione di <a class="el" href="classDcel_1_1Vertex_1_1ConstOutgoingHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge uscenti da un vertice, garantendone l&#39;immutabilità...">Dcel::Vertex::ConstOutgoingHalfEdgeIterator</a>. </p>
<dl class="section warning"><dt>Avvertimento</dt><dd>L'iteratore restituito non è un iteratore valido, e su di esso le operazioni di incremento e decremento sono inutili. Questa funzione è da utilizzarsi solamente per il <b>confronto</b> <b>con</b> <b>un</b> <b>altro</b> <b>iteratore</b> <b>valido</b> </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore di finalizzazione </dd></dl>

</div>
</div>
<a id="ad4d3e433d920cf11566efdd50d3043fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4d3e433d920cf11566efdd50d3043fa">&sect;&nbsp;</a></span>outgoingHalfEdgeEnd() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDcel_1_1Vertex_1_1OutgoingHalfEdgeIterator.html">Dcel::Vertex::OutgoingHalfEdgeIterator</a> Dcel::Vertex::outgoingHalfEdgeEnd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione di finalizzazione di <a class="el" href="classDcel_1_1Vertex_1_1OutgoingHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge uscenti da un vertice. ">Dcel::Vertex::OutgoingHalfEdgeIterator</a>. </p>
<dl class="section warning"><dt>Avvertimento</dt><dd>L'iteratore restituito non è un iteratore valido, e su di esso le operazioni di incremento e decremento sono inutili. Questa funzione è da utilizzarsi solamente per il <b>confronto</b> <b>con</b> <b>un</b> <b>altro</b> <b>iteratore</b> <b>valido</b> </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>Un iteratore di finalizzazione </dd></dl>

</div>
</div>
<a id="a9e6c739192c444e8965949e79041c1d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e6c739192c444e8965949e79041c1d1">&sect;&nbsp;</a></span>setCardinality()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Dcel::Vertex::setCardinality </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>newCardinality</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Setta la cardinalità del vertice. </p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">newCardinality</td><td>la cardinalitù che verrà settata </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9711522bca5e434f38a4dd693472017c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9711522bca5e434f38a4dd693472017c">&sect;&nbsp;</a></span>setCoordinate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Dcel::Vertex::setCoordinate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Pointd</a> &amp;&#160;</td>
          <td class="paramname"><em>newCoordinate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Setta le coordinate del vertice. </p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">newCoordinate</td><td>il punto che verrà settato </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa1478717bb5e45383acc6531c420dd57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1478717bb5e45383acc6531c420dd57">&sect;&nbsp;</a></span>setFlag()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Dcel::Vertex::setFlag </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>newFlag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Setta il flag del vertice. </p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">newFlag</td><td>il valore del flag che verrà settato </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab472df61b8c1c5671cea2367d837cdc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab472df61b8c1c5671cea2367d837cdc6">&sect;&nbsp;</a></span>setId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Dcel::Vertex::setId </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Setta l'id del vertice. </p>
<p>Questa funzione dovrebbe essere chiamata solamente dalla classe <a class="el" href="classDcel.html" title="Struttura dati Double Conntected Edge List. ">Dcel</a>.</p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>nuovo id che verrà assegnato al vertice </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7c4e583a30166edb3cac283bb60b4191"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c4e583a30166edb3cac283bb60b4191">&sect;&nbsp;</a></span>setIncidentHalfEdge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Dcel::Vertex::setIncidentHalfEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDcel_1_1HalfEdge.html">Dcel::HalfEdge</a> *&#160;</td>
          <td class="paramname"><em>newIncidentHalfEdge</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assegna un nuovo half edge incidente al vertice. </p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">newIncidentHalfEdge</td><td>puntatore all'half edge incidente assegnato al vertice </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7b7e992ed35ffdfdc24b37f8d6fc2386"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b7e992ed35ffdfdc24b37f8d6fc2386">&sect;&nbsp;</a></span>setNormal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Dcel::Vertex::setNormal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>newNormal</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Setta il vettore normale al vertice. </p>
<dl class="params"><dt>Parametri</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">newNormal</td><td>il vettore normale che verrà settato </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afa0923e4beb3ac2a23fc214fb1c414aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa0923e4beb3ac2a23fc214fb1c414aa">&sect;&nbsp;</a></span>toString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Dcel::Vertex::toString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Funzione toString di un vertice. </p>
<dl class="section return"><dt>Restituisce</dt><dd>Una stringa rappresentativa del vertice </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000010">Da fare:</a></b></dt><dd>Da aggiornare </dd></dl>

</div>
</div>
<a id="af6909cf4a951dc2504caaeaae872fde1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6909cf4a951dc2504caaeaae872fde1">&sect;&nbsp;</a></span>updateCardinality()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Dcel::Vertex::updateCardinality </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ricalcola e restituisce la cardinalità del vertice, ossia il numero di <b>edge</b> (non half edge!) incidenti. </p>
<dl class="section warning"><dt>Avvertimento</dt><dd>Utilizza <a class="el" href="classDcel_1_1Vertex_1_1ConstOutgoingHalfEdgeIterator.html" title="Iteratore che permette di ciclare sugli half edge uscenti da un vertice, garantendone l&#39;immutabilità...">Dcel::Vertex::ConstOutgoingHalfEdgeIterator</a> </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>La cardinalità del vertice appena calcolata </dd></dl>
<dl class="section user"><dt>Complessità:</dt><dd><em>O(Cardinality)</em> </dd></dl>

</div>
</div>
<a id="aa15a987ee31b7012ed0d1cb51f68d66f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa15a987ee31b7012ed0d1cb51f68d66f">&sect;&nbsp;</a></span>updateNormal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Vec3</a> Dcel::Vertex::updateNormal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ricalcola e restituisce la normale al vertice, e aggiorna la cardinalità del vertice. </p>
<dl class="section warning"><dt>Avvertimento</dt><dd>Utilizza <a class="el" href="classDcel_1_1Vertex_1_1ConstIncidentFaceIterator.html" title="Iteratore che permette di ciclare sulle facce incidenti su un vertice. ">Dcel::Vertex::ConstIncidentFaceIterator</a> </dd></dl>
<dl class="section return"><dt>Restituisce</dt><dd>La normale al vertice appena calcolata </dd></dl>
<dl class="section user"><dt>Complessità:</dt><dd><em>O(Cardinality)</em> </dd></dl>

</div>
</div>
<hr/>La documentazione per questa classe è stata generata a partire dai seguenti file:<ul>
<li><a class="el" href="dcel__vertex_8h_source.html">dcel_vertex.h</a></li>
<li>dcel_vertex.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classDcel.html">Dcel</a></li><li class="navelem"><a class="el" href="classDcel_1_1Vertex.html">Vertex</a></li>
    <li class="footer">Generato da
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.12 </li>
  </ul>
</div>
</body>
</html>
